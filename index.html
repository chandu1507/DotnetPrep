<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Full Stack Interview Prep</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>.NET Full Stack Interview Preparation</h1>
            <p>Senior Software Engineer Interview Guide</p>
        </div>
    </header>

    <nav class="main-nav">
        <div class="container">
            <ul>
                <li><a href="#oop-concepts">OOP Concepts</a></li>
                <li><a href="#dotnet-fundamentals">.NET Fundamentals</a></li>
                <li><a href="#aspnet-webapi">ASP.NET Web API</a></li>
                <li><a href="#entity-framework">Entity Framework</a></li>
                <li><a href="#authentication-authorization">Auth & Security</a></li>
                <li><a href="#windows-services">Background Services</a></li>
                <li><a href="#database-sql">Database & SQL</a></li>
                <li><a href="#enterprise-architecture">Enterprise Architecture</a></li>
                <li><a href="#cloud-azure">Cloud & Azure</a></li>
                <li><a href="#memory-management">Memory Management</a></li>
                <li><a href="#advanced-concepts">Advanced Concepts</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="oop-concepts" class="topic-section">
            <h2>Core OOP Concepts</h2>
            
            <div class="concept-card">
                <h3>Classes and Objects</h3>
                <div class="concept-content">
                    <p><strong>Class:</strong> A blueprint for creating objects. Think of it as a template in enterprise systems.</p>
                    <p><strong>Object:</strong> An instance of a class with actual data.</p>
                    <div class="example">
                        <h4>Enterprise Example:</h4>
                        <p>In an HRMS system, <code>Employee</code> is a class defining properties like Name, EmployeeID, and methods like CalculateSalary(). Each actual employee record is an object of this class.</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>The Four Pillars of OOP</h3>
                
                <div class="pillar">
                    <h4>1. Encapsulation</h4>
                    <p>Bundling data and methods together while restricting access to internal components.</p>
                    <div class="code-example">
                        <pre><code>public class Account {
    private decimal balance;
    public void Deposit(decimal amount) { balance += amount; }
    public bool Withdraw(decimal amount) {
        if(amount > balance) return false;
        balance -= amount;
        return true;
    }
}</code></pre>
                    </div>
                    <p><strong>Why:</strong> Prevents unauthorized updates and ensures business rules are enforced.</p>
                </div>

                <div class="pillar">
                    <h4>2. Inheritance</h4>
                    <p>Creating new classes based on existing ones, inheriting properties and behaviors.</p>
                    <div class="code-example">
                        <pre><code>public class User {
    public string UserName { get; set; }
    public virtual void Login() { /* generic logic */ }
}
public class AdminUser : User {
    public override void Login() { /* admin-specific logic */ }
    public void ApproveUser() { /* only admin */ }
}</code></pre>
                    </div>
                    <p><strong>Enterprise Use:</strong> Multi-tenant SaaS with different user roles and privileges.</p>
                </div>

                <div class="pillar">
                    <h4>3. Polymorphism</h4>
                    <p>One interface, multiple implementations. Enables flexible, extensible code.</p>
                    <div class="polymorphism-types">
                        <h5>Compile-time (Method Overloading)</h5>
                        <div class="code-example">
                            <pre><code>public class DocumentGenerator {
    public void Generate(int templateId) { /* ... */ }
    public void Generate(string templateName) { /* ... */ }
    public void Generate(string title, string body) { /* ... */ }
}</code></pre>
                        </div>
                        
                        <h5>Runtime (Method Overriding)</h5>
                        <div class="code-example">
                            <pre><code>public interface IReportExporter {
    void Export(Report data);
}
public class PdfExporter : IReportExporter { ... }
public class ExcelExporter : IReportExporter { ... }</code></pre>
                        </div>
                    </div>
                </div>

                <div class="pillar">
                    <h4>4. Abstraction</h4>
                    <p>Hiding complex implementation details, showing only necessary features.</p>
                    <div class="code-example">
                        <pre><code>public interface IPaymentGateway {
    PaymentResult ProcessPayment(PaymentRequest request);
}
public class StripeGateway : IPaymentGateway { ... }
public class PaypalGateway : IPaymentGateway { ... }</code></pre>
                    </div>
                    <p><strong>Benefit:</strong> Swap payment providers with minimal code changes.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>SOLID Principles</h3>
                <p class="solid-intro">These five design principles are the backbone of maintainable, extensible, and testable enterprise .NET applications.</p>
                
                <div class="solid-principle-detailed">
                    <h4>1. Single Responsibility Principle (SRP)</h4>
                    <p class="principle-definition"><strong>"Every class should have one, and only one, reason to change."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Leave Management System</h5>
                        <ul>
                            <li><code>LeaveRequestService</code> - Handles business logic (validations, balance checks)</li>
                            <li><code>LeaveRequestRepository</code> - Database operations (CRUD for leave requests)</li>
                            <li><code>LeaveNotificationService</code> - Notifications (emails/SMS for approvals)</li>
                        </ul>
                        <p><strong>Why:</strong> If business rules change, only modify LeaveRequestService. If DB schema changes, only the repository is affected.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>‚ö†Ô∏è Common Pitfall:</strong> Classes doing everything‚Äîbusiness logic, data access, email sending‚Äîbecome impossible to maintain and test.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>2. Open/Closed Principle (OCP)</h4>
                    <p class="principle-definition"><strong>"Software entities should be open for extension but closed for modification."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Invoice Generation Module</h5>
                        <div class="code-example">
                            <pre><code>public interface IInvoiceGenerator { 
    void Generate(InvoiceData data); 
}

public class GSTInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* GST logic */ }
}

public class ExportInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* Export logic */ }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Add new invoice types without touching existing code‚Äîprevents regressions.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>‚ö†Ô∏è Common Pitfall:</strong> Giant switch/case statements‚Äîevery new type requires editing old code, risking bugs.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>3. Liskov Substitution Principle (LSP)</h4>
                    <p class="principle-definition"><strong>"Subclasses should be substitutable for their base class without breaking client code."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Banking System</h5>
                        <div class="code-example">
                            <pre><code>List&lt;Account&gt; accounts = new() { 
    new SavingsAccount(), 
    new CurrentAccount() 
};

foreach(var acc in accounts) 
    acc.Withdraw(amount); // Works for all account types</code></pre>
                        </div>
                        <p><strong>Why:</strong> Prevents surprises‚Äîsubclasses maintain the parent's contract.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>‚ö†Ô∏è Common Pitfall:</strong> Derived classes that throw exceptions or do nothing‚Äîviolates LSP.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>4. Interface Segregation Principle (ISP)</h4>
                    <p class="principle-definition"><strong>"Clients should not be forced to depend on interfaces they do not use."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: User Management Module</h5>
                        <div class="code-example">
                            <pre><code>// Instead of one giant IUserService with 30+ methods:
public interface IAuthenticationService { 
    void Login(); 
    void Logout(); 
}

public interface IProfileService { 
    void UpdateProfile(); 
    UserProfile GetProfile(); 
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Admin panel only needs IProfileService, login page only needs IAuthenticationService.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>‚ö†Ô∏è Common Pitfall:</strong> Fat interfaces where changes for one client break others.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>5. Dependency Inversion Principle (DIP)</h4>
                    <p class="principle-definition"><strong>"High-level modules should not depend on low-level modules, but on abstractions."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Order Processing System</h5>
                        <div class="code-example">
                            <pre><code>public class OrderService
{
    private readonly IPaymentGateway _gateway;
    
    public OrderService(IPaymentGateway gateway) 
    { 
        _gateway = gateway; 
    }
    
    public void ProcessOrder(Order order)
    {
        // Can use StripeGateway, PayPalGateway, etc.
        _gateway.ProcessPayment(order.Total);
    }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Easy testing (mock the gateway), painless vendor switching, supports DI frameworks.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>‚ö†Ô∏è Common Pitfall:</strong> Directly instantiating dependencies inside classes‚Äîmakes code rigid and untestable.
                    </div>
                </div>

                <div class="interview-tips">
                    <h4>üéØ How to Demonstrate SOLID in Interviews</h4>
                    <ul>
                        <li><strong>Refactoring:</strong> "We split our monolithic UserService into focused services for auth, profile, and roles to reduce bugs (SRP, ISP)."</li>
                        <li><strong>Extension:</strong> "When GST laws changed, we just added a new invoice generator‚Äîexisting code didn't change (OCP)."</li>
                        <li><strong>Testing:</strong> "Using interfaces for repositories made it easy to mock dependencies for unit testing (DIP)."</li>
                        <li><strong>Bug Prevention:</strong> "We enforced LSP to fix broken polymorphism in our account hierarchy."</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="dotnet-fundamentals" class="topic-section">
            <h2>.NET Framework & .NET Core Fundamentals</h2>
            
            <div class="concept-card">
                <h3>.NET Framework vs .NET Core/.NET 5+</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>.NET Framework</th>
                                <th>.NET Core/.NET 5+</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Platform</td>
                                <td>Windows only</td>
                                <td>Cross-platform (Windows, Linux, macOS)</td>
                            </tr>
                            <tr>
                                <td>Deployment</td>
                                <td>Machine-wide installation</td>
                                <td>Side-by-side, self-contained</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>Good</td>
                                <td>Better, highly optimized</td>
                            </tr>
                            <tr>
                                <td>Use Cases</td>
                                <td>Legacy apps, WebForms, WCF, WinForms</td>
                                <td>Microservices, REST APIs, cloud-native</td>
                            </tr>
                            <tr>
                                <td>Deployment Target</td>
                                <td>On-premises servers</td>
                                <td>Containers, Azure, Docker</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="example">
                    <h4>Real Enterprise Migration:</h4>
                    <p>Many enterprises are migrating 15‚Äì20-year-old ASP.NET Framework web apps to .NET 6+ for containerization and Azure deployment, improving scalability and reducing infrastructure costs.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Solution & Project Structure</h3>
                <div class="enterprise-example">
                    <h5>Enterprise Solution Architecture</h5>
                    <div class="code-example">
                        <pre><code>MySolution/
‚îú‚îÄ‚îÄ Company.Product.WebApi/          # Web API controllers
‚îú‚îÄ‚îÄ Company.Product.Core/            # Business/domain logic
‚îú‚îÄ‚îÄ Company.Product.Data/            # EF Core/data access
‚îú‚îÄ‚îÄ Company.Product.Tests/           # Unit/integration tests
‚îî‚îÄ‚îÄ Company.Product.Infrastructure/  # External services</code></pre>
                    </div>
                    <ul>
                        <li><strong>Assembly:</strong> Output file (.dll/.exe) - unit of deployment and versioning</li>
                        <li><strong>Namespace:</strong> Logical grouping preventing naming conflicts</li>
                        <li><strong>Clean Separation:</strong> Supports maintainability, reusability, and CI/CD</li>
                    </ul>
                </div>
            </div>

            <div class="concept-card">
                <h3>CLR (Common Language Runtime) - The Execution Engine</h3>
                <p class="clr-intro">The CLR is the heart of the .NET ecosystem‚Äîit's the execution engine that actually runs your code behind the scenes, similar to the Java Virtual Machine (JVM).</p>
                
                <div class="clr-responsibilities">
                    <div class="clr-responsibility">
                        <h4>1. Just-In-Time (JIT) Compilation</h4>
                        <p>Your C# code ‚Üí IL (Intermediate Language) ‚Üí Machine code at runtime</p>
                        <div class="example">
                            <p><strong>Enterprise Example:</strong> Your web API DLL is IL until the CLR loads it and JITs only the parts actually used, making startups faster and memory usage efficient.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>2. Memory Management (Garbage Collection)</h4>
                        <p>Automatic memory allocation/deallocation prevents memory leaks</p>
                        <div class="example">
                            <p><strong>Real Use:</strong> In a high-traffic payment gateway API, object allocations for requests/responses are automatically managed, reducing memory bugs.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>3. Type Safety & Code Verification</h4>
                        <p>Prevents using objects as incompatible types, avoiding crashes and vulnerabilities</p>
                        <div class="example">
                            <p><strong>Why Important:</strong> Prevents crashes, vulnerabilities, and data corruption in multi-team enterprise projects.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>4. Exception Handling</h4>
                        <p>Structured, consistent error handling across all .NET languages</p>
                        <div class="example">
                            <p><strong>Enterprise Use:</strong> Global error handler middleware for APIs‚Äîall exceptions bubble up via CLR and can be caught/logged uniformly.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>5. Thread Management & Concurrency</h4>
                        <p>Manages threads and supports multi-threading (ThreadPool, async/await)</p>
                        <div class="example">
                            <p><strong>Enterprise Example:</strong> In high-load order processing, background workers and parallel tasks are coordinated by CLR for maximum throughput.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>6. Security & Interoperability</h4>
                        <p>Integrates with OS-level security and enables calling unmanaged code (C/C++ DLLs)</p>
                        <div class="example">
                            <p><strong>Real Use:</strong> Legacy enterprise apps calling old C++ DLLs for specialized processing, safely handled by CLR.</p>
                        </div>
                    </div>
                </div>

                <div class="clr-execution-flow">
                    <h4>üìã Typical .NET App Execution Flow</h4>
                    <div class="execution-steps">
                        <div class="step">1. Your code ‚Üí Compiled to IL (by C# compiler)</div>
                        <div class="step">2. You start the app ‚Üí CLR loads the main assembly</div>
                        <div class="step">3. CLR/JIT ‚Üí Converts IL to native code as needed</div>
                        <div class="step">4. CLR executes your code, manages memory, threads, exceptions</div>
                        <div class="step">5. App finishes ‚Üí CLR cleans up, runs finalizers, releases resources</div>
                    </div>
                </div>

                <div class="clr-cloud-deployment">
                    <h4>üåê CLR in Cloud Deployments (Azure)</h4>
                    <div class="cloud-scenarios">
                        <div class="cloud-scenario">
                            <h5>Azure App Service</h5>
                            <p>Azure provisions servers with .NET runtime pre-installed. Your API runs within the CLR‚ÄîAzure manages it for you.</p>
                        </div>
                        <div class="cloud-scenario">
                            <h5>Azure Functions</h5>
                            <p>Serverless, but still runs on VMs. Azure spins up instances with .NET runtime/CLR when functions are triggered.</p>
                        </div>
                        <div class="cloud-scenario">
                            <h5>Containers (AKS)</h5>
                            <p>You package your app with required .NET runtime. CLR runs your code inside the container.</p>
                        </div>
                    </div>
                    <div class="cloud-diagram">
                        <div class="diagram-flow">
                            <span class="diagram-step">[You]</span> ‚Üí 
                            <span class="diagram-step">[Deploy API]</span> ‚Üí 
                            <span class="diagram-step">[Azure Runtime]</span> ‚Üí 
                            <span class="diagram-step">[CLR Runs Code]</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Key C# Language Features for Enterprise</h3>
                
                <div class="language-feature">
                    <h4>Async/Await</h4>
                    <p>Non-blocking operations crucial for scalable APIs</p>
                    <div class="code-example">
                        <pre><code>public async Task&lt;ActionResult&lt;User&gt;&gt; GetUserAsync(int id)
{
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Async DB queries, file uploads, external API calls</p>
                </div>

                <div class="language-feature">
                    <h4>LINQ (Language Integrated Query)</h4>
                    <p>Strongly-typed, chainable querying for in-memory and database operations</p>
                    <div class="code-example">
                        <pre><code>var activeUsers = await _context.Users
    .Where(u => u.IsActive && u.LastLoginDate > DateTime.Now.AddDays(-30))
    .OrderBy(u => u.LastName)
    .Select(u => new UserDto { Name = u.FullName, Email = u.Email })
    .ToListAsync();</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Generics & Type Safety</h4>
                    <p>Reusable, type-safe classes and methods</p>
                    <div class="code-example">
                        <pre><code>public class Repository&lt;T&gt; where T : class
{
    private readonly DbContext _context;
    
    public async Task&lt;T&gt; GetByIdAsync(int id) => 
        await _context.Set&lt;T&gt;().FindAsync(id);
        
    public async Task AddAsync(T entity) => 
        await _context.Set&lt;T&gt;().AddAsync(entity);
}</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Delegates & Events</h4>
                    <p>Event-driven systems and pub-sub patterns</p>
                    <div class="code-example">
                        <pre><code>public event EventHandler&lt;OrderProcessedEventArgs&gt; OrderProcessed;

public async Task ProcessOrderAsync(Order order)
{
    // Process order logic
    await SaveOrderAsync(order);
    
    // Notify subscribers
    OrderProcessed?.Invoke(this, new OrderProcessedEventArgs(order));
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Real-time notifications, audit logging, workflow systems</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Dependency Injection & IoC</h3>
                <div class="di-explanation">
                    <h4>Why DI Matters in Enterprise</h4>
                    <ul>
                        <li>Promotes testability and loose coupling</li>
                        <li>Enables easy mocking for unit tests</li>
                        <li>Supports configuration-based service swapping</li>
                        <li>Facilitates clean architecture patterns</li>
                    </ul>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs / Startup.cs
builder.Services.AddScoped&lt;IUserService, UserService&gt;();
builder.Services.AddScoped&lt;IEmailService, EmailService&gt;();
builder.Services.AddSingleton&lt;IConfiguration&gt;(configuration);

// Controller
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly IEmailService _emailService;
    
    public UsersController(IUserService userService, IEmailService emailService)
    {
        _userService = userService;
        _emailService = emailService;
    }
}</code></pre>
                </div>

                <div class="di-lifetimes">
                    <h5>Service Lifetimes</h5>
                    <ul>
                        <li><strong>Transient:</strong> New instance every time (lightweight services)</li>
                        <li><strong>Scoped:</strong> One instance per request (repositories, business services)</li>
                        <li><strong>Singleton:</strong> Single instance for app lifetime (configuration, caching)</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Swap real email service for mock in integration tests without changing any business logic code.</p>
                </div>
            </div>
        </section>

        <section id="aspnet-webapi" class="topic-section">
            <h2>ASP.NET Core Web API</h2>
            
            <div class="concept-card">
                <h3>Controllers & Routing</h3>
                <p>RESTful endpoints for CRUD operations and business logic</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase 
{
    private readonly IOrderService _orderService;
    
    public OrdersController(IOrderService orderService)
    {
        _orderService = orderService;
    }
    
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; GetOrder(int id)
    {
        var order = await _orderService.GetByIdAsync(id);
        return order != null ? Ok(order) : NotFound();
    }
    
    [HttpPost]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; CreateOrder(CreateOrderRequest request)
    {
        var order = await _orderService.CreateAsync(request);
        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Model Binding & Validation</h3>
                <p>Enforces data integrity at API entry points</p>
                
                <div class="code-example">
                    <pre><code>public class CreateUserRequest
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }
    
    [Required]
    [StringLength(100, MinimumLength = 6)]
    public string Password { get; set; }
    
    [Range(18, 120)]
    public int Age { get; set; }
}

[HttpPost]
public async Task&lt;IActionResult&gt; CreateUser([FromBody] CreateUserRequest request)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
        
    // Process valid request
    var user = await _userService.CreateAsync(request);
    return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Middleware Pipeline</h3>
                <p>Components that process requests in sequence</p>
                
                <div class="middleware-pipeline">
                    <div class="middleware-component">
                        <h4>Authentication Middleware</h4>
                        <p>JWT token validation, OAuth2, Azure AD integration</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Authorization Middleware</h4>
                        <p>Role-based and policy-based access control</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Logging Middleware</h4>
                        <p>Request/response logging, correlation IDs</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Exception Handling</h4>
                        <p>Global error handling and response formatting</p>
                    </div>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs
var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();
app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();
app.UseMiddleware&lt;GlobalExceptionMiddleware&gt;();

app.MapControllers();</code></pre>
                </div>
                
                <div class="example">
                    <h4>Banking App Example:</h4>
                    <p>JWT middleware authenticates every API request, logging middleware tracks all transactions with correlation IDs for audit trails.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>API Versioning</h3>
                <p>Supports multiple API versions for backward compatibility</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[ApiVersion("1.0")]
[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public IActionResult GetUsersV1() => Ok(/* V1 response */);
    
    [HttpGet]
    [MapToApiVersion("2.0")]
    public IActionResult GetUsersV2() => Ok(/* V2 response with additional fields */);
}</code></pre>
                </div>
            </div>
        </section>

        <section id="entity-framework" class="topic-section">
            <h2>Entity Framework Core</h2>
            
            <div class="concept-card">
                <h3>ORM & Database Mapping</h3>
                <p>Maps database tables to C# classes with LINQ support</p>
                
                <div class="code-example">
                    <pre><code>public class User
{
    public int Id { get; set; }
    public string Email { get; set; }
    public DateTime CreatedOn { get; set; }
    public string CreatedBy { get; set; }
    
    // Navigation properties
    public virtual ICollection&lt;Order&gt; Orders { get; set; }
}

public class ApplicationDbContext : DbContext
{
    public DbSet&lt;User&gt; Users { get; set; }
    public DbSet&lt;Order&gt; Orders { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;User&gt;()
            .HasIndex(u => u.Email)
            .IsUnique();
            
        modelBuilder.Entity&lt;Order&gt;()
            .HasOne(o => o.User)
            .WithMany(u => u.Orders)
            .HasForeignKey(o => o.UserId);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migrations & Schema Management</h3>
                <p>Version-controlled database schema changes</p>
                
                <div class="migration-commands">
                    <div class="command-group">
                        <h4>Common EF Core Commands</h4>
                        <div class="code-example">
                            <pre><code># Add new migration
dotnet ef migrations add AddUserTable

# Update database
dotnet ef database update

# Generate SQL script
dotnet ef migrations script</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Enterprise Benefit:</h4>
                    <p>Critical for team collaboration and CI/CD pipelines. Database changes are tracked, versioned, and can be automatically applied during deployments.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>DbContext & Unit of Work</h3>
                <p>Manages queries, change tracking, and transactions</p>
                
                <div class="code-example">
                    <pre><code>public class OrderService
{
    private readonly ApplicationDbContext _context;
    
    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task&lt;Order&gt; CreateOrderAsync(CreateOrderRequest request)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            var order = new Order { /* map properties */ };
            _context.Orders.Add(order);
            
            // Update inventory
            var product = await _context.Products.FindAsync(request.ProductId);
            product.Stock -= request.Quantity;
            
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
            
            return order;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Auto-generating audit columns (CreatedOn, ModifiedBy) via EF Core conventions and interceptors for compliance requirements.</p>
                </div>
            </div>
        </section>

        <section id="authentication-authorization" class="topic-section">
            <h2>Authentication & Authorization</h2>
            
            <div class="concept-card">
                <h3>Authentication - "Who are you?"</h3>
                
                <div class="auth-methods">
                    <div class="auth-method">
                        <h4>JWT Tokens</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = configuration["Jwt:Issuer"],
            ValidAudience = configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(configuration["Jwt:Key"]))
        };
    });</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-method">
                        <h4>OAuth2 & Azure AD</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApp(configuration.GetSection("AzureAd"));</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Authorization - "What can you do?"</h3>
                
                <div class="authorization-types">
                    <div class="auth-type">
                        <h4>Role-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>[Authorize(Roles = "Admin,Manager")]
public class AdminController : ControllerBase
{
    [HttpDelete("users/{id}")]
    [Authorize(Roles = "Admin")]
    public async Task&lt;IActionResult&gt; DeleteUser(int id) { /* */ }
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-type">
                        <h4>Policy-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthorization(options =>
{
    options.AddPolicy("CanManageUsers", policy =>
        policy.RequireClaim("permission", "users.manage"));
        
    options.AddPolicy("MinimumAge", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

[Authorize(Policy = "CanManageUsers")]
public class UserManagementController : ControllerBase { /* */ }</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>HRMS system with role-based access: Employees can view their own data, Managers can approve leave requests, HR Admins can manage all employee records.</p>
                </div>
            </div>
        </section>

        <section id="windows-services" class="topic-section">
            <h2>Windows Services & Background Jobs</h2>
            
            <div class="concept-card">
                <h3>Background Services Use Cases</h3>
                <ul class="service-use-cases">
                    <li>Scheduled database cleanup and maintenance</li>
                    <li>Email sending and notification processing</li>
                    <li>Data import/export operations</li>
                    <li>ETL (Extract, Transform, Load) jobs</li>
                    <li>File processing and monitoring</li>
                    <li>Report generation and distribution</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>.NET Worker Service</h3>
                <p>Modern approach for background services in .NET</p>
                
                <div class="code-example">
                    <pre><code>public class InvoiceProcessingService : BackgroundService
{
    private readonly ILogger&lt;InvoiceProcessingService&gt; _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public InvoiceProcessingService(
        ILogger&lt;InvoiceProcessingService&gt; logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var invoiceService = scope.ServiceProvider
                    .GetRequiredService&lt;IInvoiceService&gt;();
                
                await invoiceService.ProcessPendingInvoicesAsync();
                
                _logger.LogInformation("Invoice processing completed at {Time}", 
                    DateTimeOffset.Now);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing invoices");
            }
            
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Deployment as Windows Service</h3>
                
                <div class="code-example">
                    <pre><code># Install as Windows Service
sc create "InvoiceProcessor" binpath="C:\Services\InvoiceProcessor.exe"

# Start the service
sc start "InvoiceProcessor"

# Or use .NET CLI
dotnet publish -c Release
sc create "MyService" binpath="C:\MyApp\MyService.exe"</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Background invoice processing service that runs nightly, processes pending invoices, generates PDFs, sends emails, and logs progress for monitoring and troubleshooting.</p>
                </div>
            </div>
        </section>

        <section id="database-sql" class="topic-section">
            <h2>Database & SQL Server</h2>
            
            <div class="concept-card">
                <h3>Enterprise Database Concepts</h3>
                
                <div class="db-concept">
                    <h4>Complex Queries & Joins</h4>
                    <p>Healthcare EMR system example: joining patient, appointment, and treatment tables for comprehensive reports.</p>
                </div>

                <div class="db-concept">
                    <h4>Transactions</h4>
                    <p>ACID properties ensure data consistency in financial operations.</p>
                    <div class="code-example">
                        <pre><code>using (var transaction = context.Database.BeginTransaction()) {
    try {
        // Debit from source account
        sourceAccount.Balance -= amount;
        // Credit to destination account
        destAccount.Balance += amount;
        
        context.SaveChanges();
        transaction.Commit();
    } catch {
        transaction.Rollback();
        throw;
    }
}</code></pre>
                    </div>
                </div>

                <div class="db-concept">
                    <h4>Entity Framework</h4>
                    <p>ORM for mapping database tables to C# classes, simplifying CRUD operations.</p>
                    <ul>
                        <li>Code-First: Define models, generate database</li>
                        <li>Database-First: Generate models from existing database</li>
                        <li>Migrations: Version control for database schema</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="enterprise-architecture" class="topic-section">
            <h2>Enterprise Application Architecture</h2>
            
            <div class="concept-card">
                <h3>Layered Architecture</h3>
                <div class="architecture-layers">
                    <div class="layer">
                        <h4>Presentation Layer</h4>
                        <p>Controllers, Views, API endpoints</p>
                    </div>
                    <div class="layer">
                        <h4>Business Logic Layer</h4>
                        <p>Services, business rules, validation</p>
                    </div>
                    <div class="layer">
                        <h4>Data Access Layer</h4>
                        <p>Repositories, Entity Framework, database operations</p>
                    </div>
                    <div class="layer">
                        <h4>Database Layer</h4>
                        <p>SQL Server, stored procedures, data storage</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Integration Patterns</h3>
                <ul class="integration-list">
                    <li><strong>APIs:</strong> REST/GraphQL for system communication</li>
                    <li><strong>Message Queues:</strong> Azure Service Bus for async processing</li>
                    <li><strong>ETL Jobs:</strong> Data transformation between systems</li>
                    <li><strong>Event-Driven:</strong> Microservices communication</li>
                </ul>
            </div>
        </section>

        <section id="cloud-azure" class="topic-section">
            <h2>Cloud (Azure) & Modernization</h2>
            
            <div class="concept-card">
                <h3>Azure Services for .NET</h3>
                <div class="azure-services">
                    <div class="service">
                        <h4>Azure App Service</h4>
                        <p>Host web applications and APIs with auto-scaling</p>
                    </div>
                    <div class="service">
                        <h4>Azure SQL Database</h4>
                        <p>Managed SQL Server in the cloud</p>
                    </div>
                    <div class="service">
                        <h4>Azure Functions</h4>
                        <p>Serverless computing for scheduled tasks</p>
                    </div>
                    <div class="service">
                        <h4>Azure Service Bus</h4>
                        <p>Message queuing for decoupled systems</p>
                    </div>
                    <div class="service">
                        <h4>Azure Active Directory</h4>
                        <p>Identity and access management</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migration Strategies</h3>
                <ul>
                    <li><strong>Lift and Shift:</strong> Move existing apps to cloud VMs</li>
                    <li><strong>Re-platform:</strong> Move to Azure App Service with minimal changes</li>
                    <li><strong>Refactor:</strong> Redesign for cloud-native features</li>
                    <li><strong>Hybrid:</strong> Keep some components on-premises, others in cloud</li>
                </ul>
            </div>
        </section>

        <section id="memory-management" class="topic-section">
            <h2>Memory Management & Garbage Collection</h2>
            
            <div class="concept-card">
                <h3>Understanding .NET Garbage Collection</h3>
                <div class="gc-overview">
                    <p>The .NET Garbage Collector automatically frees up memory by cleaning up objects that your application is no longer using. It's <strong>heap-wide, not per object or per class</strong>.</p>
                </div>
                
                <div class="gc-process">
                    <h4>How Garbage Collection Works</h4>
                    <div class="gc-steps">
                        <div class="gc-step">
                            <h5>1. Roots & Reachability</h5>
                            <p>GC starts from <em>roots</em>:</p>
                            <ul>
                                <li>Local variables in running methods</li>
                                <li>Static fields</li>
                                <li>CPU registers</li>
                                <li>Application threads</li>
                            </ul>
                        </div>
                        
                        <div class="gc-step">
                            <h5>2. Mark Phase</h5>
                            <p>GC walks from roots, marking all reachable objects (directly or indirectly referenced)</p>
                        </div>
                        
                        <div class="gc-step">
                            <h5>3. Sweep Phase</h5>
                            <p>Any object <strong>not marked</strong> (unreachable) is considered "garbage" and eligible for collection</p>
                        </div>
                        
                        <div class="gc-step">
                            <h5>4. Compacting</h5>
                            <p>GC compacts memory (removes gaps left by deleted objects), improving memory locality</p>
                        </div>
                    </div>
                </div>

                <div class="gc-circular-references">
                    <h4>Handling Object Relationships & Circular References</h4>
                    <div class="code-example">
                        <pre><code>public class Order 
{ 
    public Invoice LinkedInvoice { get; set; } 
}

public class Invoice 
{ 
    public Order LinkedOrder { get; set; } 
}

// If both objects only reference each other, 
// but nothing else references them from roots,
// GC will collect BOTH objects automatically</code></pre>
                    </div>
                    <div class="example">
                        <h4>Key Point:</h4>
                        <p>If objects are <strong>only referencing each other</strong> but are not reachable from any root, the entire group is eligible for cleanup. .NET GC handles circular references automatically.</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Generational Garbage Collection</h3>
                <div class="gc-generations">
                    <div class="generation">
                        <h4>Generation 0 (Gen 0)</h4>
                        <div class="gen-content">
                            <p><strong>Newly created objects</strong> (short-lived)</p>
                            <ul>
                                <li>Temporary variables</li>
                                <li>Request/response objects</li>
                                <li>Method-scoped objects</li>
                            </ul>
                            <p><strong>Collection:</strong> Most frequent, fastest</p>
                        </div>
                    </div>
                    
                    <div class="generation">
                        <h4>Generation 1 (Gen 1)</h4>
                        <div class="gen-content">
                            <p><strong>Objects surviving one collection</strong></p>
                            <ul>
                                <li>Medium-lived objects</li>
                                <li>Objects that survived Gen 0 cleanup</li>
                            </ul>
                            <p><strong>Collection:</strong> Less frequent</p>
                        </div>
                    </div>
                    
                    <div class="generation">
                        <h4>Generation 2 (Gen 2)</h4>
                        <div class="gen-content">
                            <p><strong>Long-lived objects</strong></p>
                            <ul>
                                <li>Singletons</li>
                                <li>Application-wide caches</li>
                                <li>Static objects</li>
                            </ul>
                            <p><strong>Collection:</strong> Least frequent, most expensive</p>
                        </div>
                    </div>
                </div>
                
                <div class="gc-why-generational">
                    <h4>Why Generational?</h4>
                    <p><strong>Performance Optimization:</strong> Most objects die young (temporary objects). Focusing on Gen 0 first is faster and more efficient than scanning the entire heap every time.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Memory Management Best Practices</h3>
                
                <div class="memory-practices">
                    <div class="practice">
                        <h4>‚ùå Avoid Manual GC.Collect()</h4>
                        <p>Not recommended in enterprise apps unless you have a very specific performance reason. The GC is optimized to run automatically.</p>
                    </div>
                    
                    <div class="practice">
                        <h4>‚úÖ Use IDisposable for Unmanaged Resources</h4>
                        <div class="code-example">
                            <pre><code>using (var fileStream = new FileStream("data.txt", FileMode.Open))
{
    // File handle is automatically disposed
    // even if an exception occurs
}

// Or with using declarations (C# 8+)
using var connection = new SqlConnection(connectionString);
// Disposed at end of scope</code></pre>
                        </div>
                        <p><strong>Use for:</strong> File handles, database connections, network sockets‚Äînot for regular object memory.</p>
                    </div>
                    
                    <div class="practice">
                        <h4>‚úÖ Remove References When Done</h4>
                        <div class="code-example">
                            <pre><code>// Instead of keeping large collections in memory
private static List&lt;Order&gt; _processedOrders = new();

// Clear when no longer needed
public void CompleteProcessing()
{
    // Process orders...
    _processedOrders.Clear(); // Allow GC to collect
    _processedOrders = null;  // Remove reference entirely
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="practice">
                        <h4>‚ö†Ô∏è Watch for Memory Leaks</h4>
                        <ul>
                            <li><strong>Event handlers:</strong> Unsubscribe from events</li>
                            <li><strong>Static collections:</strong> Clear when no longer needed</li>
                            <li><strong>Caching:</strong> Implement cache expiration</li>
                            <li><strong>Timers:</strong> Dispose properly</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Enterprise Memory Management Scenarios</h3>
                
                <div class="enterprise-scenarios">
                    <div class="scenario">
                        <h4>High-Traffic Web APIs</h4>
                        <p>Request/response objects are automatically managed by GC. Focus on not holding references to request data beyond the request scope.</p>
                    </div>
                    
                    <div class="scenario">
                        <h4>Background Services</h4>
                        <p>Long-running services should be careful about accumulating objects in static collections or event handlers that never get cleared.</p>
                    </div>
                    
                    <div class="scenario">
                        <h4>Data Processing Applications</h4>
                        <p>When processing large datasets, process in chunks and allow intermediate objects to be collected between batches.</p>
                    </div>
                </div>
            </div>

            <div class="interview-tips">
                <h4>üéØ Interview-Ready Summary</h4>
                <p>".NET's garbage collector periodically scans the managed heap for objects that are no longer reachable from application roots (like local variables, static fields, or threads). It works by marking all reachable objects, then collecting everything else‚Äîeven if those unreachable objects reference each other. The process operates across the heap in generations, which makes memory management efficient and automatic for enterprise applications."</p>
            </div>
        </section>

        <section id="advanced-concepts" class="topic-section">
            <h2>Advanced Concepts</h2>
            
            <div class="concept-card">
                <h3>Design Patterns</h3>
                <div class="patterns">
                    <div class="pattern">
                        <h4>Repository Pattern</h4>
                        <p>Decouples data access logic from business logic</p>
                        <div class="code-example">
                            <pre><code>public interface IUserRepository {
    Task&lt;User&gt; GetByIdAsync(int id);
    Task&lt;IEnumerable&lt;User&gt;&gt; GetAllAsync();
    Task AddAsync(User user);
}</code></pre>
                        </div>
                    </div>
                    <div class="pattern">
                        <h4>Unit of Work</h4>
                        <p>Maintains transaction consistency across multiple repositories</p>
                    </div>
                    <div class="pattern">
                        <h4>Factory Pattern</h4>
                        <p>Creates objects without specifying exact classes - useful in workflow engines</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Asynchronous Programming</h3>
                <div class="async-content">
                    <h4>async/await Pattern</h4>
                    <div class="code-example">
                        <pre><code>public async Task&lt;IActionResult&gt; GetUserAsync(int id) {
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Benefits:</strong> Better scalability, non-blocking operations, improved user experience</p>
                    <p><strong>Use Cases:</strong> File uploads, database operations, external API calls</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Security Best Practices</h3>
                <ul class="security-list">
                    <li><strong>Authentication:</strong> JWT tokens, OAuth2, Azure AD integration</li>
                    <li><strong>Authorization:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Data Protection:</strong> Encryption at rest and in transit</li>
                    <li><strong>Input Validation:</strong> Prevent SQL injection, XSS attacks</li>
                    <li><strong>HTTPS:</strong> Secure communication channels</li>
                </ul>
            </div>
        </section>

        <section id="best-practices" class="topic-section">
            <h2>Best Practices & DevOps</h2>
            
            <div class="concept-card">
                <h3>Code Quality</h3>
                <ul class="best-practices-list">
                    <li><strong>Clean Code:</strong> Descriptive naming, single responsibility</li>
                    <li><strong>Error Handling:</strong> Try-catch blocks, custom exceptions, logging</li>
                    <li><strong>Unit Testing:</strong> xUnit, NUnit, mocking with Moq</li>
                    <li><strong>Code Reviews:</strong> Peer review process, SOLID principles enforcement</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>DevOps & CI/CD</h3>
                <div class="devops-practices">
                    <div class="practice">
                        <h4>Azure DevOps Pipelines</h4>
                        <p>Automated build, test, and deployment processes</p>
                    </div>
                    <div class="practice">
                        <h4>Monitoring & Logging</h4>
                        <p>Application Insights, structured logging with Serilog</p>
                    </div>
                    <div class="practice">
                        <h4>Performance Optimization</h4>
                        <p>Profiling, query optimization, caching strategies</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Legacy System Maintenance</h3>
                <p>Working with 20+ year old platforms requires:</p>
                <ul>
                    <li>Careful integration between old and new components</li>
                    <li>Gradual migration strategies</li>
                    <li>Maintaining business continuity</li>
                    <li>Documentation of existing systems</li>
                    <li>Risk assessment for changes</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 .NET Interview Preparation Guide</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>
