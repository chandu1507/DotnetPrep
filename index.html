<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Full Stack Interview Prep</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>.NET Full Stack Interview Preparation</h1>
            <p>Senior Software Engineer Interview Guide</p>
        </div>
    </header>

    <nav class="main-nav">
        <div class="container">
            <ul>
                <li><a href="#oop-concepts">OOP Concepts</a></li>
                <li><a href="#dotnet-fundamentals">.NET Fundamentals</a></li>
                <li><a href="#aspnet-webapi">ASP.NET Web API</a></li>
                <li><a href="#entity-framework">Entity Framework</a></li>
                <li><a href="#authentication-authorization">Auth & Security</a></li>
                <li><a href="#windows-services">Background Services</a></li>
                <li><a href="#database-sql">Database & SQL</a></li>
                <li><a href="#enterprise-architecture">Enterprise Architecture</a></li>
                <li><a href="#cloud-azure">Cloud & Azure</a></li>
                <li><a href="#memory-management">Memory Management</a></li>
                <li><a href="#advanced-concepts">Advanced Concepts</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="oop-concepts" class="topic-section">
            <h2>Core OOP Concepts</h2>
            
            <div class="concept-card">
                <h3>Classes and Objects</h3>
                <div class="concept-content">
                    <p><strong>Class:</strong> A blueprint for creating objects. Think of it as a template in enterprise systems.</p>
                    <p><strong>Object:</strong> An instance of a class with actual data.</p>
                    <div class="example">
                        <h4>Enterprise Example:</h4>
                        <p>In an HRMS system, <code>Employee</code> is a class defining properties like Name, EmployeeID, and methods like CalculateSalary(). Each actual employee record is an object of this class.</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>The Four Pillars of OOP</h3>
                
                <div class="pillar">
                    <h4>1. Encapsulation</h4>
                    <p>Bundling data and methods together while restricting access to internal components.</p>
                    <div class="code-example">
                        <pre><code>public class Account {
    private decimal balance;
    public void Deposit(decimal amount) { balance += amount; }
    public bool Withdraw(decimal amount) {
        if(amount > balance) return false;
        balance -= amount;
        return true;
    }
}</code></pre>
                    </div>
                    <p><strong>Why:</strong> Prevents unauthorized updates and ensures business rules are enforced.</p>
                </div>

                <div class="pillar">
                    <h4>2. Inheritance</h4>
                    <p>Creating new classes based on existing ones, inheriting properties and behaviors.</p>
                    <div class="code-example">
                        <pre><code>public class User {
    public string UserName { get; set; }
    public virtual void Login() { /* generic logic */ }
}
public class AdminUser : User {
    public override void Login() { /* admin-specific logic */ }
    public void ApproveUser() { /* only admin */ }
}</code></pre>
                    </div>
                    <p><strong>Enterprise Use:</strong> Multi-tenant SaaS with different user roles and privileges.</p>
                </div>

                <div class="pillar">
                    <h4>3. Polymorphism</h4>
                    <p>One interface, multiple implementations. Enables flexible, extensible code.</p>
                    <div class="polymorphism-types">
                        <h5>Compile-time (Method Overloading)</h5>
                        <div class="code-example">
                            <pre><code>public class DocumentGenerator {
    public void Generate(int templateId) { /* ... */ }
    public void Generate(string templateName) { /* ... */ }
    public void Generate(string title, string body) { /* ... */ }
}</code></pre>
                        </div>
                        
                        <h5>Runtime (Method Overriding)</h5>
                        <div class="code-example">
                            <pre><code>public interface IReportExporter {
    void Export(Report data);
}
public class PdfExporter : IReportExporter { ... }
public class ExcelExporter : IReportExporter { ... }</code></pre>
                        </div>
                    </div>
                </div>

                <div class="pillar">
                    <h4>4. Abstraction</h4>
                    <p>Hiding complex implementation details, showing only necessary features.</p>
                    <div class="code-example">
                        <pre><code>public interface IPaymentGateway {
    PaymentResult ProcessPayment(PaymentRequest request);
}
public class StripeGateway : IPaymentGateway { ... }
public class PaypalGateway : IPaymentGateway { ... }</code></pre>
                    </div>
                    <p><strong>Benefit:</strong> Swap payment providers with minimal code changes.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>SOLID Principles</h3>
                <p class="solid-intro">These five design principles are the backbone of maintainable, extensible, and testable enterprise .NET applications.</p>
                
                <div class="solid-principle-detailed">
                    <h4>1. Single Responsibility Principle (SRP)</h4>
                    <p class="principle-definition"><strong>"Every class should have one, and only one, reason to change."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Leave Management System</h5>
                        <ul>
                            <li><code>LeaveRequestService</code> - Handles business logic (validations, balance checks)</li>
                            <li><code>LeaveRequestRepository</code> - Database operations (CRUD for leave requests)</li>
                            <li><code>LeaveNotificationService</code> - Notifications (emails/SMS for approvals)</li>
                        </ul>
                        <p><strong>Why:</strong> If business rules change, only modify LeaveRequestService. If DB schema changes, only the repository is affected.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Classes doing everything—business logic, data access, email sending—become impossible to maintain and test.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>2. Open/Closed Principle (OCP)</h4>
                    <p class="principle-definition"><strong>"Software entities should be open for extension but closed for modification."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Invoice Generation Module</h5>
                        <div class="code-example">
                            <pre><code>public interface IInvoiceGenerator { 
    void Generate(InvoiceData data); 
}

public class GSTInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* GST logic */ }
}

public class ExportInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* Export logic */ }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Add new invoice types without touching existing code—prevents regressions.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Giant switch/case statements—every new type requires editing old code, risking bugs.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>3. Liskov Substitution Principle (LSP)</h4>
                    <p class="principle-definition"><strong>"Subclasses should be substitutable for their base class without breaking client code."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Banking System</h5>
                        <div class="code-example">
                            <pre><code>List&lt;Account&gt; accounts = new() { 
    new SavingsAccount(), 
    new CurrentAccount() 
};

foreach(var acc in accounts) 
    acc.Withdraw(amount); // Works for all account types</code></pre>
                        </div>
                        <p><strong>Why:</strong> Prevents surprises—subclasses maintain the parent's contract.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Derived classes that throw exceptions or do nothing—violates LSP.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>4. Interface Segregation Principle (ISP)</h4>
                    <p class="principle-definition"><strong>"Clients should not be forced to depend on interfaces they do not use."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: User Management Module</h5>
                        <div class="code-example">
                            <pre><code>// Instead of one giant IUserService with 30+ methods:
public interface IAuthenticationService { 
    void Login(); 
    void Logout(); 
}

public interface IProfileService { 
    void UpdateProfile(); 
    UserProfile GetProfile(); 
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Admin panel only needs IProfileService, login page only needs IAuthenticationService.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Fat interfaces where changes for one client break others.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>5. Dependency Inversion Principle (DIP)</h4>
                    <p class="principle-definition"><strong>"High-level modules should not depend on low-level modules, but on abstractions."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Order Processing System</h5>
                        <div class="code-example">
                            <pre><code>public class OrderService
{
    private readonly IPaymentGateway _gateway;
    
    public OrderService(IPaymentGateway gateway) 
    { 
        _gateway = gateway; 
    }
    
    public void ProcessOrder(Order order)
    {
        // Can use StripeGateway, PayPalGateway, etc.
        _gateway.ProcessPayment(order.Total);
    }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Easy testing (mock the gateway), painless vendor switching, supports DI frameworks.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Directly instantiating dependencies inside classes—makes code rigid and untestable.
                    </div>
                </div>

                <div class="interview-tips">
                    <h4>🎯 How to Demonstrate SOLID in Interviews</h4>
                    <ul>
                        <li><strong>Refactoring:</strong> "We split our monolithic UserService into focused services for auth, profile, and roles to reduce bugs (SRP, ISP)."</li>
                        <li><strong>Extension:</strong> "When GST laws changed, we just added a new invoice generator—existing code didn't change (OCP)."</li>
                        <li><strong>Testing:</strong> "Using interfaces for repositories made it easy to mock dependencies for unit testing (DIP)."</li>
                        <li><strong>Bug Prevention:</strong> "We enforced LSP to fix broken polymorphism in our account hierarchy."</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="dotnet-fundamentals" class="topic-section">
            <h2>.NET Framework & .NET Core Fundamentals</h2>
            
            <div class="concept-card">
                <h3>.NET Framework vs .NET Core/.NET 5+</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>.NET Framework</th>
                                <th>.NET Core/.NET 5+</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Platform</td>
                                <td>Windows only</td>
                                <td>Cross-platform (Windows, Linux, macOS)</td>
                            </tr>
                            <tr>
                                <td>Deployment</td>
                                <td>Machine-wide installation</td>
                                <td>Side-by-side, self-contained</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>Good</td>
                                <td>Better, highly optimized</td>
                            </tr>
                            <tr>
                                <td>Use Cases</td>
                                <td>Legacy apps, WebForms, WCF, WinForms</td>
                                <td>Microservices, REST APIs, cloud-native</td>
                            </tr>
                            <tr>
                                <td>Deployment Target</td>
                                <td>On-premises servers</td>
                                <td>Containers, Azure, Docker</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="example">
                    <h4>Real Enterprise Migration:</h4>
                    <p>Many enterprises are migrating 15–20-year-old ASP.NET Framework web apps to .NET 6+ for containerization and Azure deployment, improving scalability and reducing infrastructure costs.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Solution & Project Structure</h3>
                <div class="enterprise-example">
                    <h5>Enterprise Solution Architecture</h5>
                    <div class="code-example">
                        <pre><code>MySolution/
├── Company.Product.WebApi/          # Web API controllers
├── Company.Product.Core/            # Business/domain logic
├── Company.Product.Data/            # EF Core/data access
├── Company.Product.Tests/           # Unit/integration tests
└── Company.Product.Infrastructure/  # External services</code></pre>
                    </div>
                    <ul>
                        <li><strong>Assembly:</strong> Output file (.dll/.exe) - unit of deployment and versioning</li>
                        <li><strong>Namespace:</strong> Logical grouping preventing naming conflicts</li>
                        <li><strong>Clean Separation:</strong> Supports maintainability, reusability, and CI/CD</li>
                    </ul>
                </div>
            </div>

            <div class="concept-card">
                <h3>CLR (Common Language Runtime) - The Execution Engine</h3>
                <p class="clr-intro">The CLR is the heart of the .NET ecosystem—it's the execution engine that actually runs your code behind the scenes, similar to the Java Virtual Machine (JVM).</p>
                
                <div class="clr-responsibilities">
                    <div class="clr-responsibility">
                        <h4>1. Just-In-Time (JIT) Compilation</h4>
                        <p>Your C# code → IL (Intermediate Language) → Machine code at runtime</p>
                        <div class="example">
                            <p><strong>Enterprise Example:</strong> Your web API DLL is IL until the CLR loads it and JITs only the parts actually used, making startups faster and memory usage efficient.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>2. Memory Management (Garbage Collection)</h4>
                        <p>Automatic memory allocation/deallocation prevents memory leaks</p>
                        <div class="example">
                            <p><strong>Real Use:</strong> In a high-traffic payment gateway API, object allocations for requests/responses are automatically managed, reducing memory bugs.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>3. Type Safety & Code Verification</h4>
                        <p>Prevents using objects as incompatible types, avoiding crashes and vulnerabilities</p>
                        <div class="example">
                            <p><strong>Why Important:</strong> Prevents crashes, vulnerabilities, and data corruption in multi-team enterprise projects.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>4. Exception Handling</h4>
                        <p>Structured, consistent error handling across all .NET languages</p>
                        <div class="example">
                            <p><strong>Enterprise Use:</strong> Global error handler middleware for APIs—all exceptions bubble up via CLR and can be caught/logged uniformly.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>5. Thread Management & Concurrency</h4>
                        <p>Manages threads and supports multi-threading (ThreadPool, async/await)</p>
                        <div class="example">
                            <p><strong>Enterprise Example:</strong> In high-load order processing, background workers and parallel tasks are coordinated by CLR for maximum throughput.</p>
                        </div>
                    </div>

                    <div class="clr-responsibility">
                        <h4>6. Security & Interoperability</h4>
                        <p>Integrates with OS-level security and enables calling unmanaged code (C/C++ DLLs)</p>
                        <div class="example">
                            <p><strong>Real Use:</strong> Legacy enterprise apps calling old C++ DLLs for specialized processing, safely handled by CLR.</p>
                        </div>
                    </div>
                </div>

                <div class="clr-execution-flow">
                    <h4>📋 Typical .NET App Execution Flow</h4>
                    <div class="execution-steps">
                        <div class="step">1. Your code → Compiled to IL (by C# compiler)</div>
                        <div class="step">2. You start the app → CLR loads the main assembly</div>
                        <div class="step">3. CLR/JIT → Converts IL to native code as needed</div>
                        <div class="step">4. CLR executes your code, manages memory, threads, exceptions</div>
                        <div class="step">5. App finishes → CLR cleans up, runs finalizers, releases resources</div>
                    </div>
                </div>

                <div class="clr-cloud-deployment">
                    <h4>🌐 CLR in Cloud Deployments (Azure)</h4>
                    <div class="cloud-scenarios">
                        <div class="cloud-scenario">
                            <h5>Azure App Service</h5>
                            <p>Azure provisions servers with .NET runtime pre-installed. Your API runs within the CLR—Azure manages it for you.</p>
                        </div>
                        <div class="cloud-scenario">
                            <h5>Azure Functions</h5>
                            <p>Serverless, but still runs on VMs. Azure spins up instances with .NET runtime/CLR when functions are triggered.</p>
                        </div>
                        <div class="cloud-scenario">
                            <h5>Containers (AKS)</h5>
                            <p>You package your app with required .NET runtime. CLR runs your code inside the container.</p>
                        </div>
                    </div>
                    <div class="cloud-diagram">
                        <div class="diagram-flow">
                            <span class="diagram-step">[You]</span> → 
                            <span class="diagram-step">[Deploy API]</span> → 
                            <span class="diagram-step">[Azure Runtime]</span> → 
                            <span class="diagram-step">[CLR Runs Code]</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Key C# Language Features for Enterprise</h3>
                
                <div class="language-feature">
                    <h4>Async/Await</h4>
                    <p>Non-blocking operations crucial for scalable APIs</p>
                    <div class="code-example">
                        <pre><code>public async Task&lt;ActionResult&lt;User&gt;&gt; GetUserAsync(int id)
{
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Async DB queries, file uploads, external API calls</p>
                </div>

                <div class="language-feature">
                    <h4>LINQ (Language Integrated Query)</h4>
                    <p>Strongly-typed, chainable querying for in-memory and database operations</p>
                    <div class="code-example">
                        <pre><code>var activeUsers = await _context.Users
    .Where(u => u.IsActive && u.LastLoginDate > DateTime.Now.AddDays(-30))
    .OrderBy(u => u.LastName)
    .Select(u => new UserDto { Name = u.FullName, Email = u.Email })
    .ToListAsync();</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Generics & Type Safety</h4>
                    <p>Reusable, type-safe classes and methods</p>
                    <div class="code-example">
                        <pre><code>public class Repository&lt;T&gt; where T : class
{
    private readonly DbContext _context;
    
    public async Task&lt;T&gt; GetByIdAsync(int id) => 
        await _context.Set&lt;T&gt;().FindAsync(id);
        
    public async Task AddAsync(T entity) => 
        await _context.Set&lt;T&gt;().AddAsync(entity);
}</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Delegates & Events</h4>
                    <p>Event-driven systems and pub-sub patterns</p>
                    <div class="code-example">
                        <pre><code>public event EventHandler&lt;OrderProcessedEventArgs&gt; OrderProcessed;

public async Task ProcessOrderAsync(Order order)
{
    // Process order logic
    await SaveOrderAsync(order);
    
    // Notify subscribers
    OrderProcessed?.Invoke(this, new OrderProcessedEventArgs(order));
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Real-time notifications, audit logging, workflow systems</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Dependency Injection & IoC</h3>
                <div class="di-explanation">
                    <h4>Why DI Matters in Enterprise</h4>
                    <ul>
                        <li>Promotes testability and loose coupling</li>
                        <li>Enables easy mocking for unit tests</li>
                        <li>Supports configuration-based service swapping</li>
                        <li>Facilitates clean architecture patterns</li>
                    </ul>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs / Startup.cs
builder.Services.AddScoped&lt;IUserService, UserService&gt;();
builder.Services.AddScoped&lt;IEmailService, EmailService&gt;();
builder.Services.AddSingleton&lt;IConfiguration&gt;(configuration);

// Controller
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly IEmailService _emailService;
    
    public UsersController(IUserService userService, IEmailService emailService)
    {
        _userService = userService;
        _emailService = emailService;
    }
}</code></pre>
                </div>

                <div class="di-lifetimes">
                    <h5>Service Lifetimes</h5>
                    <ul>
                        <li><strong>Transient:</strong> New instance every time (lightweight services)</li>
                        <li><strong>Scoped:</strong> One instance per request (repositories, business services)</li>
                        <li><strong>Singleton:</strong> Single instance for app lifetime (configuration, caching)</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Swap real email service for mock in integration tests without changing any business logic code.</p>
                </div>
            </div>
        </section>

        <section id="aspnet-webapi" class="topic-section">
            <h2>ASP.NET Core Web API</h2>
            
            <div class="concept-card">
                <h3>Controllers & Routing</h3>
                <p>RESTful endpoints for CRUD operations and business logic</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase 
{
    private readonly IOrderService _orderService;
    
    public OrdersController(IOrderService orderService)
    {
        _orderService = orderService;
    }
    
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; GetOrder(int id)
    {
        var order = await _orderService.GetByIdAsync(id);
        return order != null ? Ok(order) : NotFound();
    }
    
    [HttpPost]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; CreateOrder(CreateOrderRequest request)
    {
        var order = await _orderService.CreateAsync(request);
        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Model Binding & Validation</h3>
                <p>Enforces data integrity at API entry points</p>
                
                <div class="code-example">
                    <pre><code>public class CreateUserRequest
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }
    
    [Required]
    [StringLength(100, MinimumLength = 6)]
    public string Password { get; set; }
    
    [Range(18, 120)]
    public int Age { get; set; }
}

[HttpPost]
public async Task&lt;IActionResult&gt; CreateUser([FromBody] CreateUserRequest request)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
        
    // Process valid request
    var user = await _userService.CreateAsync(request);
    return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Middleware Pipeline</h3>
                <p>Components that process requests in sequence</p>
                
                <div class="middleware-pipeline">
                    <div class="middleware-component">
                        <h4>Authentication Middleware</h4>
                        <p>JWT token validation, OAuth2, Azure AD integration</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Authorization Middleware</h4>
                        <p>Role-based and policy-based access control</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Logging Middleware</h4>
                        <p>Request/response logging, correlation IDs</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Exception Handling</h4>
                        <p>Global error handling and response formatting</p>
                    </div>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs
var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();
app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();
app.UseMiddleware&lt;GlobalExceptionMiddleware&gt;();

app.MapControllers();</code></pre>
                </div>
                
                <div class="example">
                    <h4>Banking App Example:</h4>
                    <p>JWT middleware authenticates every API request, logging middleware tracks all transactions with correlation IDs for audit trails.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>API Versioning</h3>
                <p>Supports multiple API versions for backward compatibility</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[ApiVersion("1.0")]
[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public IActionResult GetUsersV1() => Ok(/* V1 response */);
    
    [HttpGet]
    [MapToApiVersion("2.0")]
    public IActionResult GetUsersV2() => Ok(/* V2 response with additional fields */);
}</code></pre>
                </div>
            </div>
        </section>

        <section id="entity-framework" class="topic-section">
            <h2>Entity Framework Core</h2>
            
            <div class="concept-card">
                <h3>ORM & Database Mapping</h3>
                <p>Maps database tables to C# classes with LINQ support</p>
                
                <div class="code-example">
                    <pre><code>public class User
{
    public int Id { get; set; }
    public string Email { get; set; }
    public DateTime CreatedOn { get; set; }
    public string CreatedBy { get; set; }
    
    // Navigation properties
    public virtual ICollection&lt;Order&gt; Orders { get; set; }
}

public class ApplicationDbContext : DbContext
{
    public DbSet&lt;User&gt; Users { get; set; }
    public DbSet&lt;Order&gt; Orders { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;User&gt;()
            .HasIndex(u => u.Email)
            .IsUnique();
            
        modelBuilder.Entity&lt;Order&gt;()
            .HasOne(o => o.User)
            .WithMany(u => u.Orders)
            .HasForeignKey(o => o.UserId);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migrations & Schema Management</h3>
                <p>Version-controlled database schema changes</p>
                
                <div class="migration-commands">
                    <div class="command-group">
                        <h4>Common EF Core Commands</h4>
                        <div class="code-example">
                            <pre><code># Add new migration
dotnet ef migrations add AddUserTable

# Update database
dotnet ef database update

# Generate SQL script
dotnet ef migrations script</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Enterprise Benefit:</h4>
                    <p>Critical for team collaboration and CI/CD pipelines. Database changes are tracked, versioned, and can be automatically applied during deployments.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>DbContext & Unit of Work</h3>
                <p>Manages queries, change tracking, and transactions</p>
                
                <div class="code-example">
                    <pre><code>public class OrderService
{
    private readonly ApplicationDbContext _context;
    
    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task&lt;Order&gt; CreateOrderAsync(CreateOrderRequest request)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            var order = new Order { /* map properties */ };
            _context.Orders.Add(order);
            
            // Update inventory
            var product = await _context.Products.FindAsync(request.ProductId);
            product.Stock -= request.Quantity;
            
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
            
            return order;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Auto-generating audit columns (CreatedOn, ModifiedBy) via EF Core conventions and interceptors for compliance requirements.</p>
                </div>
            </div>
        </section>

        <section id="authentication-authorization" class="topic-section">
            <h2>Authentication & Authorization</h2>
            
            <div class="concept-card">
                <h3>Authentication - "Who are you?"</h3>
                
                <div class="auth-methods">
                    <div class="auth-method">
                        <h4>JWT Tokens</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = configuration["Jwt:Issuer"],
            ValidAudience = configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(configuration["Jwt:Key"]))
        };
    });</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-method">
                        <h4>OAuth2 & Azure AD</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApp(configuration.GetSection("AzureAd"));</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Authorization - "What can you do?"</h3>
                
                <div class="authorization-types">
                    <div class="auth-type">
                        <h4>Role-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>[Authorize(Roles = "Admin,Manager")]
public class AdminController : ControllerBase
{
    [HttpDelete("users/{id}")]
    [Authorize(Roles = "Admin")]
    public async Task&lt;IActionResult&gt; DeleteUser(int id) { /* */ }
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-type">
                        <h4>Policy-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthorization(options =>
{
    options.AddPolicy("CanManageUsers", policy =>
        policy.RequireClaim("permission", "users.manage"));
        
    options.AddPolicy("MinimumAge", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

[Authorize(Policy = "CanManageUsers")]
public class UserManagementController : ControllerBase { /* */ }</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>HRMS system with role-based access: Employees can view their own data, Managers can approve leave requests, HR Admins can manage all employee records.</p>
                </div>
            </div>
        </section>

        <section id="windows-services" class="topic-section">
            <h2>Windows Services & Background Jobs</h2>
            
            <div class="concept-card">
                <h3>Background Services Use Cases</h3>
                <ul class="service-use-cases">
                    <li>Scheduled database cleanup and maintenance</li>
                    <li>Email sending and notification processing</li>
                    <li>Data import/export operations</li>
                    <li>ETL (Extract, Transform, Load) jobs</li>
                    <li>File processing and monitoring</li>
                    <li>Report generation and distribution</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>.NET Worker Service</h3>
                <p>Modern approach for background services in .NET</p>
                
                <div class="code-example">
                    <pre><code>public class InvoiceProcessingService : BackgroundService
{
    private readonly ILogger&lt;InvoiceProcessingService&gt; _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public InvoiceProcessingService(
        ILogger&lt;InvoiceProcessingService&gt; logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var invoiceService = scope.ServiceProvider
                    .GetRequiredService&lt;IInvoiceService&gt;();
                
                await invoiceService.ProcessPendingInvoicesAsync();
                
                _logger.LogInformation("Invoice processing completed at {Time}", 
                    DateTimeOffset.Now);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing invoices");
            }
            
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Deployment as Windows Service</h3>
                
                <div class="code-example">
                    <pre><code># Install as Windows Service
sc create "InvoiceProcessor" binpath="C:\Services\InvoiceProcessor.exe"

# Start the service
sc start "InvoiceProcessor"

# Or use .NET CLI
dotnet publish -c Release
sc create "MyService" binpath="C:\MyApp\MyService.exe"</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Background invoice processing service that runs nightly, processes pending invoices, generates PDFs, sends emails, and logs progress for monitoring and troubleshooting.</p>
                </div>
            </div>
        </section>

        <section id="database-sql" class="topic-section">
            <h2>Database & SQL Server</h2>
            
            <div class="concept-card">
                <h3>Enterprise Database Concepts</h3>
                
                <div class="db-concept">
                    <h4>Complex Queries & Joins</h4>
                    <p>Healthcare EMR system example: joining patient, appointment, and treatment tables for comprehensive reports.</p>
                </div>

                <div class="db-concept">
                    <h4>Transactions</h4>
                    <p>ACID properties ensure data consistency in financial operations.</p>
                    <div class="code-example">
                        <pre><code>using (var transaction = context.Database.BeginTransaction()) {
    try {
        // Debit from source account
        sourceAccount.Balance -= amount;
        // Credit to destination account
        destAccount.Balance += amount;
        
        context.SaveChanges();
        transaction.Commit();
    } catch {
        transaction.Rollback();
        throw;
    }
}</code></pre>
                    </div>
                </div>

                <div class="db-concept">
                    <h4>Entity Framework</h4>
                    <p>ORM for mapping database tables to C# classes, simplifying CRUD operations.</p>
                    <ul>
                        <li>Code-First: Define models, generate database</li>
                        <li>Database-First: Generate models from existing database</li>
                        <li>Migrations: Version control for database schema</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="enterprise-architecture" class="topic-section">
            <h2>Enterprise Application Architecture</h2>
            
            <div class="concept-card">
                <h3>Layered Architecture</h3>
                <div class="architecture-layers">
                    <div class="layer">
                        <h4>Presentation Layer</h4>
                        <p>Controllers, Views, API endpoints</p>
                    </div>
                    <div class="layer">
                        <h4>Business Logic Layer</h4>
                        <p>Services, business rules, validation</p>
                    </div>
                    <div class="layer">
                        <h4>Data Access Layer</h4>
                        <p>Repositories, Entity Framework, database operations</p>
                    </div>
                    <div class="layer">
                        <h4>Database Layer</h4>
                        <p>SQL Server, stored procedures, data storage</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Integration Patterns</h3>
                <ul class="integration-list">
                    <li><strong>APIs:</strong> REST/GraphQL for system communication</li>
                    <li><strong>Message Queues:</strong> Azure Service Bus for async processing</li>
                    <li><strong>ETL Jobs:</strong> Data transformation between systems</li>
                    <li><strong>Event-Driven:</strong> Microservices communication</li>
                </ul>
            </div>
        </section>

        <section id="cloud-azure" class="topic-section">
            <h2>Cloud (Azure) & Modernization</h2>
            
            <div class="concept-card">
                <h3>Azure Services for .NET</h3>
                <div class="azure-services">
                    <div class="service">
                        <h4>Azure App Service</h4>
                        <p>Host web applications and APIs with auto-scaling</p>
                    </div>
                    <div class="service">
                        <h4>Azure SQL Database</h4>
                        <p>Managed SQL Server in the cloud</p>
                    </div>
                    <div class="service">
                        <h4>Azure Functions</h4>
                        <p>Serverless computing for scheduled tasks</p>
                    </div>
                    <div class="service">
                        <h4>Azure Service Bus</h4>
                        <p>Message queuing for decoupled systems</p>
                    </div>
                    <div class="service">
                        <h4>Azure Active Directory</h4>
                        <p>Identity and access management</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migration Strategies</h3>
                <ul>
                    <li><strong>Lift and Shift:</strong> Move existing apps to cloud VMs</li>
                    <li><strong>Re-platform:</strong> Move to Azure App Service with minimal changes</li>
                    <li><strong>Refactor:</strong> Redesign for cloud-native features</li>
                    <li><strong>Hybrid:</strong> Keep some components on-premises, others in cloud</li>
                </ul>
            </div>
        </section>

        <section id="memory-management" class="topic-section">
            <h2>Memory Management & Garbage Collection</h2>
            
            <div class="concept-card">
                <h3>Understanding .NET Garbage Collection</h3>
                <div class="gc-overview">
                    <p>The .NET Garbage Collector automatically frees up memory by cleaning up objects that your application is no longer using. It's <strong>heap-wide, not per object or per class</strong>.</p>
                </div>
                
                <div class="gc-process">
                    <h4>How Garbage Collection Works</h4>
                    <div class="gc-steps">
                        <div class="gc-step">
                            <h5>1. Roots & Reachability</h5>
                            <p>GC starts from <em>roots</em>:</p>
                            <ul>
                                <li>Local variables in running methods</li>
                                <li>Static fields</li>
                                <li>CPU registers</li>
                                <li>Application threads</li>
                            </ul>
                        </div>
                        
                        <div class="gc-step">
                            <h5>2. Mark Phase</h5>
                            <p>GC walks from roots, marking all reachable objects (directly or indirectly referenced)</p>
                        </div>
                        
                        <div class="gc-step">
                            <h5>3. Sweep Phase</h5>
                            <p>Any object <strong>not marked</strong> (unreachable) is considered "garbage" and eligible for collection</p>
                        </div>
                        
                        <div class="gc-step">
                            <h5>4. Compacting</h5>
                            <p>GC compacts memory (removes gaps left by deleted objects), improving memory locality</p>
                        </div>
                    </div>
                </div>

                <div class="gc-circular-references">
                    <h4>Handling Object Relationships & Circular References</h4>
                    <div class="code-example">
                        <pre><code>public class Order 
{ 
    public Invoice LinkedInvoice { get; set; } 
}

public class Invoice 
{ 
    public Order LinkedOrder { get; set; } 
}

// If both objects only reference each other, 
// but nothing else references them from roots,
// GC will collect BOTH objects automatically</code></pre>
                    </div>
                    <div class="example">
                        <h4>Key Point:</h4>
                        <p>If objects are <strong>only referencing each other</strong> but are not reachable from any root, the entire group is eligible for cleanup. .NET GC handles circular references automatically.</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Generational Garbage Collection Deep Dive</h3>
                <div class="gc-concept-intro">
                    <p>The .NET GC is <strong>generational</strong>—it divides the heap into three generations to manage objects based on their lifespan. The core principle: <em>most objects die young, so clean them up quickly and often; older objects are collected less frequently.</em></p>
                </div>

                <div class="gc-generations">
                    <div class="generation">
                        <h4>Generation 0 (Gen 0)</h4>
                        <div class="gen-content">
                            <p><strong>Where new objects are allocated</strong> (short-lived)</p>
                            <div class="gen-details">
                                <h5>Enterprise Examples:</h5>
                                <ul>
                                    <li>Temporary data structures in web API calls</li>
                                    <li>Request/response models</li>
                                    <li>String concatenations, quick calculations</li>
                                    <li>Local variables in methods</li>
                                </ul>
                                <div class="gen-behavior">
                                    <strong>GC Behavior:</strong> Most frequent, fastest collections. Triggered when Gen 0 fills up.
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="generation">
                        <h4>Generation 1 (Gen 1)</h4>
                        <div class="gen-content">
                            <p><strong>Buffer zone</strong> between short-lived and long-lived objects</p>
                            <div class="gen-details">
                                <h5>Enterprise Examples:</h5>
                                <ul>
                                    <li>Collections/data structures living across a few requests</li>
                                    <li>Objects used during batch processing</li>
                                    <li>Workflow step objects</li>
                                    <li>Session-scoped data</li>
                                </ul>
                                <div class="gen-behavior">
                                    <strong>GC Behavior:</strong> Less frequent than Gen 0, more frequent than Gen 2.
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="generation">
                        <h4>Generation 2 (Gen 2)</h4>
                        <div class="gen-content">
                            <p><strong>Long-lived objects</strong> (application lifetime)</p>
                            <div class="gen-details">
                                <h5>Enterprise Examples:</h5>
                                <ul>
                                    <li>Application-wide singletons</li>
                                    <li>Configuration caches, logging services</li>
                                    <li>Static/global objects</li>
                                    <li>Large in-memory caches, connection pools</li>
                                </ul>
                                <div class="gen-behavior">
                                    <strong>GC Behavior:</strong> Least frequent (full GC), most expensive in terms of pause time.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="object-promotion">
                    <h4>📈 Object Promotion Flow</h4>
                    <div class="promotion-flow">
                        <div class="promotion-step">
                            <div class="step-box">New Object</div>
                            <div class="arrow">→</div>
                            <div class="step-box gen0">Gen 0</div>
                        </div>
                        <div class="promotion-step">
                            <div class="step-box gen0">Survives Collection</div>
                            <div class="arrow">→</div>
                            <div class="step-box gen1">Gen 1</div>
                        </div>
                        <div class="promotion-step">
                            <div class="step-box gen1">Survives Again</div>
                            <div class="arrow">→</div>
                            <div class="step-box gen2">Gen 2</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>How GC Traversal Actually Works</h3>
                <div class="gc-traversal-key">
                    <h4>🔑 Key Point</h4>
                    <p>Garbage Collection does <strong>NOT always traverse all generations</strong> every time. It usually only collects the youngest generation that's full (typically Gen 0), unless memory pressure requires checking older generations.</p>
                </div>

                <div class="gc-collection-types">
                    <div class="collection-type">
                        <h4>Minor Collection (Gen 0 Only)</h4>
                        <div class="collection-scenario">
                            <h5>When: Gen 0 is full</h5>
                            <div class="collection-steps">
                                <div class="step">1. GC scans Gen 0 for live objects</div>
                                <div class="step">2. Dead objects are collected (memory reclaimed)</div>
                                <div class="step">3. Surviving objects are promoted to Gen 1</div>
                                <div class="step">4. Gen 1 and Gen 2 are <strong>not touched</strong></div>
                            </div>
                        </div>
                    </div>

                    <div class="collection-type">
                        <h4>Gen 1 Collection (Gen 0 + Gen 1)</h4>
                        <div class="collection-scenario">
                            <h5>When: Not enough memory after Gen 0 collection</h5>
                            <div class="collection-steps">
                                <div class="step">1. GC traverses Gen 0 and Gen 1</div>
                                <div class="step">2. Collects dead objects in both generations</div>
                                <div class="step">3. Live objects in Gen 1 promoted to Gen 2</div>
                                <div class="step">4. Gen 2 remains untouched</div>
                            </div>
                        </div>
                    </div>

                    <div class="collection-type">
                        <h4>Full Collection (All Generations)</h4>
                        <div class="collection-scenario">
                            <h5>When: High memory pressure or explicit request</h5>
                            <div class="collection-steps">
                                <div class="step">1. GC traverses all three generations</div>
                                <div class="step">2. Collects dead objects across entire heap</div>
                                <div class="step">3. Most expensive operation</div>
                                <div class="step">4. Longest application pause</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="gc-example-scenario">
                    <h4>🎯 Real-World Example</h4>
                    <div class="scenario-description">
                        <p><strong>Starting State:</strong></p>
                        <ul>
                            <li>Gen 0: 10 objects (8 dead, 2 alive)</li>
                            <li>Gen 1: 5 objects (2 dead, 3 alive)</li>
                            <li>Gen 2: 3 objects (all alive)</li>
                        </ul>
                    </div>

                    <div class="gc-results-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Generation</th>
                                    <th>Before GC</th>
                                    <th>After Minor GC</th>
                                    <th>After Gen 1 GC</th>
                                    <th>After Full GC</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Gen 0</strong></td>
                                    <td>10 objects</td>
                                    <td>0 (2 promoted to Gen 1)</td>
                                    <td>0</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td><strong>Gen 1</strong></td>
                                    <td>5 objects</td>
                                    <td>7 (5 + 2 from Gen 0)</td>
                                    <td>0 (3 promoted to Gen 2)</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td><strong>Gen 2</strong></td>
                                    <td>3 objects</td>
                                    <td>3 (unchanged)</td>
                                    <td>6 (3 + 3 from Gen 1)</td>
                                    <td>6 (if all still alive)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="gc-frequency-summary">
                    <h4>📊 Collection Frequency Summary</h4>
                    <div class="frequency-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Collection Type</th>
                                    <th>What's Collected</th>
                                    <th>When It Happens</th>
                                    <th>Performance Impact</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Gen 0 (Minor)</strong></td>
                                    <td>Only Gen 0</td>
                                    <td>Most frequent</td>
                                    <td>Minimal pause</td>
                                </tr>
                                <tr>
                                    <td><strong>Gen 1</strong></td>
                                    <td>Gen 0 + Gen 1</td>
                                    <td>When Gen 1 fills up</td>
                                    <td>Short pause</td>
                                </tr>
                                <tr>
                                    <td><strong>Gen 2 (Full)</strong></td>
                                    <td>All generations</td>
                                    <td>High memory pressure</td>
                                    <td>Longest pause</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="interview-tips">
                    <h4>🎯 Interview-Ready Summary</h4>
                    <p>"In .NET, the GC primarily collects only the youngest generation that's full, not all generations every time. Only when necessary—like under memory pressure—does it traverse and collect higher generations. Surviving objects get promoted to the next generation. This keeps memory management fast and efficient for most enterprise workloads."</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Managed vs Unmanaged Resources</h3>
                
                <div class="resource-comparison">
                    <div class="resource-type managed">
                        <h4>🔵 Managed Resources</h4>
                        <div class="resource-details">
                            <p><strong>Definition:</strong> Objects and memory allocated and controlled by the .NET runtime (CLR)</p>
                            <h5>Examples:</h5>
                            <ul>
                                <li>C# objects (classes, arrays, collections)</li>
                                <li>Memory on the managed heap</li>
                                <li>References between .NET objects</li>
                                <li>String objects, List&lt;T&gt;, custom classes</li>
                            </ul>
                            <div class="cleanup-info">
                                <strong>Cleanup:</strong> Garbage Collector automatically tracks and frees when no longer in use
                            </div>
                        </div>
                    </div>

                    <div class="resource-type unmanaged">
                        <h4>🔴 Unmanaged Resources</h4>
                        <div class="resource-details">
                            <p><strong>Definition:</strong> Resources outside the control of the .NET runtime—provided by OS or native libraries</p>
                            <h5>Examples:</h5>
                            <ul>
                                <li>File handles (FileStream opens files)</li>
                                <li>Database connections (SqlConnection)</li>
                                <li>Network sockets, window handles</li>
                                <li>Memory allocated by C/C++ (via interop)</li>
                                <li>Images, printer handles, COM objects</li>
                            </ul>
                            <div class="cleanup-info critical">
                                <strong>Cleanup:</strong> Must be explicitly released using IDisposable pattern
                            </div>
                        </div>
                    </div>
                </div>

                <div class="why-gc-cant-cleanup">
                    <h4>❓ Why Can't GC Clean Up Everything Automatically?</h4>
                    <div class="gc-limitations">
                        <div class="limitation">
                            <h5>1. Lack of Awareness</h5>
                            <p>The CLR and GC <strong>don't know</strong> what native resources your object is holding or how to release them. Only you know how to close a Windows file handle via WinAPI.</p>
                        </div>
                        
                        <div class="limitation">
                            <h5>2. Resource Ownership</h5>
                            <p>OS-level handles, DB connections, and other resources are <strong>outside .NET's memory model</strong>. Only explicit calls like <code>.Close()</code> or <code>.Dispose()</code> can tell the OS to release them.</p>
                        </div>
                        
                        <div class="limitation">
                            <h5>3. Timing and Predictability</h5>
                            <p>GC is <strong>non-deterministic</strong>—it may run minutes after an object is no longer referenced. Unmanaged resources are usually <strong>scarce and critical</strong>, so they must be released immediately to avoid:</p>
                            <ul>
                                <li>File locks preventing other processes</li>
                                <li>Database connection pool exhaustion</li>
                                <li>Orphaned sockets and memory leaks</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="idisposable-pattern">
                    <h4>🛠️ The IDisposable Pattern</h4>
                    <div class="pattern-explanation">
                        <p>Types that hold unmanaged resources (e.g., FileStream, SqlConnection) implement <code>IDisposable</code>. When you call <code>.Dispose()</code> or use a <code>using</code> block, the resource is released immediately.</p>
                    </div>

                    <div class="code-example">
                        <pre><code>// Deterministic cleanup with using statement
using (var fileStream = new FileStream("data.txt", FileMode.Open))
{
    // File handle is automatically disposed
    // even if an exception occurs
} // Dispose() called here automatically

// C# 8+ using declarations
using var connection = new SqlConnection(connectionString);
await connection.OpenAsync();
// Disposed at end of scope automatically</code></pre>
                    </div>

                    <div class="finalizer-warning">
                        <h5>⚠️ Finalizers as Backup</h5>
                        <p>If you forget to dispose, a <strong>finalizer</strong> (<code>~ClassName()</code>) might release the resource eventually, but this is slow and unreliable—<strong>always dispose deterministically</strong>.</p>
                    </div>
                </div>

                <div class="resource-comparison-table">
                    <h4>📊 Resource Comparison</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>Managed Resource</th>
                                <th>Unmanaged Resource</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Example</strong></td>
                                <td>List&lt;T&gt;, string, custom class</td>
                                <td>File handle, DB connection, socket, image</td>
                            </tr>
                            <tr>
                                <td><strong>Cleaned by</strong></td>
                                <td>Garbage Collector</td>
                                <td>Must be disposed explicitly (Dispose())</td>
                            </tr>
                            <tr>
                                <td><strong>Memory only?</strong></td>
                                <td>Yes</td>
                                <td>No—often OS or hardware resource</td>
                            </tr>
                            <tr>
                                <td><strong>Deterministic?</strong></td>
                                <td>No (GC runs when it wants)</td>
                                <td>Yes, with using or Dispose()</td>
                            </tr>
                            <tr>
                                <td><strong>Performance Impact</strong></td>
                                <td>Minimal (handled by GC)</td>
                                <td>Critical (resource leaks if not disposed)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="concept-card">
                <h3>Singletons and Garbage Collection</h3>
                
                <div class="singleton-gc-intro">
                    <p>Understanding how <strong>singleton services in Dependency Injection</strong> interact with garbage collection is crucial for enterprise applications with long-running processes.</p>
                </div>

                <div class="singleton-lifecycle">
                    <h4>🔄 Singleton Lifecycle in DI</h4>
                    <div class="lifecycle-explanation">
                        <p>In ASP.NET Core DI, a <strong>singleton</strong> service is created <strong>once per application lifetime</strong> and shared everywhere it's injected.</p>
                        
                        <div class="code-example">
                            <pre><code>// Registration
services.AddSingleton&lt;IMyService, MyService&gt;();

// The same instance is injected everywhere</code></pre>
                        </div>
                    </div>

                    <div class="gc-singleton-interaction">
                        <h5>How GC Handles Singleton Services</h5>
                        <div class="interaction-points">
                            <div class="interaction-point">
                                <strong>1. Strong Reference:</strong> The DI container holds a strong reference to the singleton instance for the entire app lifetime
                            </div>
                            <div class="interaction-point">
                                <strong>2. GC Protection:</strong> As long as the container is alive (app is running), the singleton <strong>cannot be garbage collected</strong>
                            </div>
                            <div class="interaction-point">
                                <strong>3. Memory Pinning:</strong> GC only collects objects with no live references—the DI container "pins" the singleton in memory
                            </div>
                        </div>
                    </div>
                </div>

                <div class="singleton-shutdown">
                    <h4>🔚 Application Shutdown Process</h4>
                    <div class="shutdown-steps">
                        <div class="shutdown-step">
                            <h5>1. DI Container Disposal</h5>
                            <p>When the application shuts down, the DI container itself is disposed</p>
                        </div>
                        <div class="shutdown-step">
                            <h5>2. Singleton Cleanup</h5>
                            <p>All singleton services that implement <code>IDisposable</code> have their <code>Dispose()</code> method called</p>
                        </div>
                        <div class="shutdown-step">
                            <h5>3. GC Eligibility</h5>
                            <p>After disposal, references are dropped and the singleton becomes eligible for garbage collection</p>
                        </div>
                    </div>
                </div>

                <div class="singleton-example">
                    <h4>💡 Enterprise Example</h4>
                    <div class="code-example">
                        <pre><code>public class DatabaseConnectionManager : IDisposable
{
    private readonly SqlConnection _connection;
    private readonly ILogger&lt;DatabaseConnectionManager&gt; _logger;

    public DatabaseConnectionManager(IConfiguration config, ILogger&lt;DatabaseConnectionManager&gt; logger)
    {
        _logger = logger;
        _connection = new SqlConnection(config.GetConnectionString("Default"));
        _connection.Open();
        _logger.LogInformation("Database connection opened for application lifetime");
    }

    public async Task&lt;T&gt; ExecuteQueryAsync&lt;T&gt;(string query)
    {
        // Use the long-lived connection
        // This connection stays open for the entire app lifetime
        return await SomeQueryMethod&lt;T&gt;(query);
    }

    public void Dispose()
    {
        _logger.LogInformation("Disposing database connection at application shutdown");
        _connection?.Dispose();
    }
}

// Registration
services.AddSingleton&lt;DatabaseConnectionManager&gt;();</code></pre>
                    </div>
                    
                    <div class="example-explanation">
                        <ul>
                            <li>When the app starts, one instance is created and connection opened</li>
                            <li>The GC cannot collect this service until app shutdown</li>
                            <li>At shutdown, <code>Dispose()</code> is called, DB connection is released</li>
                            <li>Only then can GC clean up the object</li>
                        </ul>
                    </div>
                </div>

                <div class="singleton-best-practices">
                    <h4>⚠️ Enterprise Considerations</h4>
                    <div class="considerations">
                        <div class="consideration">
                            <h5>Resource Usage</h5>
                            <p><strong>Don't hold large objects</strong> in a singleton (e.g., huge caches) unless you mean for them to live for the whole app's lifetime.</p>
                        </div>
                        
                        <div class="consideration">
                            <h5>Memory Leaks</h5>
                            <p>If a singleton holds references to other objects (or events), those will also stay alive as long as the singleton lives. Avoid using singletons for request- or user-specific data.</p>
                        </div>
                        
                        <div class="consideration">
                            <h5>Dispose Pattern</h5>
                            <p>If your singleton holds unmanaged resources, <strong>always implement IDisposable</strong> and release those resources in <code>Dispose()</code>.</p>
                        </div>
                    </div>
                </div>

                <div class="di-lifetime-comparison">
                    <h4>📊 DI Lifetime Comparison</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Lifetime</th>
                                <th>Singleton Service</th>
                                <th>Regular Object</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Lifetime</strong></td>
                                <td>App-wide (held by DI container)</td>
                                <td>Variable (local, transient)</td>
                            </tr>
                            <tr>
                                <td><strong>Collected by GC</strong></td>
                                <td>Only after DI container disposed</td>
                                <td>When no references exist</td>
                            </tr>
                            <tr>
                                <td><strong>Dispose() Called</strong></td>
                                <td>At app shutdown (if IDisposable)</td>
                                <td>When out of scope (if used in using)</td>
                            </tr>
                            <tr>
                                <td><strong>Memory Impact</strong></td>
                                <td>Persistent for entire app lifetime</td>
                                <td>Released when scope ends</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="interview-tips">
                    <h4>🎯 Interview-Ready Summary</h4>
                    <p>"Singleton DI services in .NET Core live for the entire application lifetime because the DI container holds a strong reference to them. The garbage collector can't reclaim their memory until the application stops and the DI container is disposed, at which point any IDisposable singletons are also disposed. That's why it's crucial to use singletons only for truly shared resources and to clean up unmanaged resources properly in Dispose()."</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Memory Management Best Practices</h3>
                
                <div class="memory-practices">
                    <div class="practice">
                        <h4>❌ Avoid Manual GC.Collect()</h4>
                        <p>Not recommended in enterprise apps unless you have a very specific performance reason. The GC is optimized to run automatically.</p>
                    </div>
                    
                    <div class="practice">
                        <h4>✅ Use IDisposable for Unmanaged Resources</h4>
                        <div class="code-example">
                            <pre><code>using (var fileStream = new FileStream("data.txt", FileMode.Open))
{
    // File handle is automatically disposed
    // even if an exception occurs
}

// Or with using declarations (C# 8+)
using var connection = new SqlConnection(connectionString);
// Disposed at end of scope</code></pre>
                        </div>
                        <p><strong>Use for:</strong> File handles, database connections, network sockets—not for regular object memory.</p>
                    </div>
                    
                    <div class="practice">
                        <h4>✅ Remove References When Done</h4>
                        <div class="code-example">
                            <pre><code>// Instead of keeping large collections in memory
private static List&lt;Order&gt; _processedOrders = new();

// Clear when no longer needed
public void CompleteProcessing()
{
    // Process orders...
    _processedOrders.Clear(); // Allow GC to collect
    _processedOrders = null;  // Remove reference entirely
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="practice">
                        <h4>⚠️ Watch for Memory Leaks</h4>
                        <ul>
                            <li><strong>Event handlers:</strong> Unsubscribe from events</li>
                            <li><strong>Static collections:</strong> Clear when no longer needed</li>
                            <li><strong>Caching:</strong> Implement cache expiration</li>
                            <li><strong>Timers:</strong> Dispose properly</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Enterprise Memory Management Scenarios</h3>
                
                <div class="enterprise-scenarios">
                    <div class="scenario">
                        <h4>High-Traffic Web APIs</h4>
                        <p>Request/response objects are automatically managed by GC. Focus on not holding references to request data beyond the request scope.</p>
                    </div>
                    
                    <div class="scenario">
                        <h4>Background Services</h4>
                        <p>Long-running services should be careful about accumulating objects in static collections or event handlers that never get cleared.</p>
                    </div>
                    
                    <div class="scenario">
                        <h4>Data Processing Applications</h4>
                        <p>When processing large datasets, process in chunks and allow intermediate objects to be collected between batches.</p>
                    </div>
                </div>
            </div>

            <div class="interview-tips">
                <h4>🎯 Interview-Ready Summary</h4>
                <p>".NET's garbage collector periodically scans the managed heap for objects that are no longer reachable from application roots (like local variables, static fields, or threads). It works by marking all reachable objects, then collecting everything else—even if those unreachable objects reference each other. The process operates across the heap in generations, which makes memory management efficient and automatic for enterprise applications."</p>
            </div>
        </section>

        <section id="advanced-concepts" class="topic-section">
            <h2>Advanced Concepts</h2>
            
            <div class="concept-card">
                <h3>Exception Handling (Try-Catch-Finally)</h3>
                
                <div class="exception-intro">
                    <p>Proper exception handling is crucial in enterprise applications for maintaining system stability, logging errors, and providing graceful degradation of functionality.</p>
                </div>

                <div class="exception-flow">
                    <h4>📋 Exception Handling Flow</h4>
                    <div class="flow-blocks">
                        <div class="flow-block try-block">
                            <h5>try Block</h5>
                            <p>Contains code that <em>might throw</em> an exception</p>
                            <ul>
                                <li>Database access</li>
                                <li>File I/O operations</li>
                                <li>External API calls</li>
                                <li>Network operations</li>
                            </ul>
                        </div>
                        
                        <div class="flow-arrow">→</div>
                        
                        <div class="flow-block catch-block">
                            <h5>catch Block</h5>
                            <p>Handles the exception when it occurs</p>
                            <ul>
                                <li>Logging errors</li>
                                <li>Returning safe responses</li>
                                <li>Implementing retry logic</li>
                                <li>Graceful degradation</li>
                            </ul>
                        </div>
                        
                        <div class="flow-arrow">→</div>
                        
                        <div class="flow-block finally-block">
                            <h5>finally Block</h5>
                            <p>Code that <strong>always runs</strong></p>
                            <ul>
                                <li>Closing connections</li>
                                <li>Releasing resources</li>
                                <li>Cleanup operations</li>
                                <li>Logging completion</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="enterprise-example">
                    <h4>🏢 Enterprise Example: Database Repository</h4>
                    <div class="code-example">
                        <pre><code>public async Task&lt;bool&gt; UpdateCustomerAsync(int customerId, string newName)
{
    SqlConnection connection = null;
    try
    {
        connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();

        // Database operation that might throw
        var command = new SqlCommand(
            "UPDATE Customers SET Name = @Name WHERE Id = @Id", 
            connection);
        command.Parameters.AddWithValue("@Name", newName);
        command.Parameters.AddWithValue("@Id", customerId);
        
        int rowsAffected = await command.ExecuteNonQueryAsync();
        
        _logger.LogInformation("Customer {CustomerId} updated successfully", customerId);
        return rowsAffected > 0;
    }
    catch (SqlException ex)
    {
        // Handle database-specific errors
        _logger.LogError(ex, "Database error updating customer {CustomerId}", customerId);
        
        // Decide whether to re-throw or return failure
        if (ex.Number == 2) // Timeout
        {
            throw new TimeoutException("Database operation timed out", ex);
        }
        
        return false;
    }
    catch (Exception ex)
    {
        // Handle any other unexpected errors
        _logger.LogError(ex, "Unexpected error updating customer {CustomerId}", customerId);
        throw; // Re-throw to preserve stack trace
    }
    finally
    {
        // Always cleanup - runs whether exception occurred or not
        if (connection != null)
        {
            await connection.DisposeAsync();
            _logger.LogDebug("Database connection closed");
        }
    }
}</code></pre>
                    </div>
                </div>

                <div class="modern-patterns">
                    <h4>🆕 Modern Exception Handling Patterns</h4>
                    
                    <div class="pattern-comparison">
                        <div class="pattern-old">
                            <h5>Traditional Approach</h5>
                            <div class="code-example">
                                <pre><code>SqlConnection conn = null;
try
{
    conn = new SqlConnection(connString);
    conn.Open();
    // Database operations
}
catch (SqlException ex)
{
    // Handle error
}
finally
{
    conn?.Dispose(); // Manual cleanup
}</code></pre>
                            </div>
                        </div>

                        <div class="pattern-modern">
                            <h5>Modern Approach (using statement)</h5>
                            <div class="code-example">
                                <pre><code>try
{
    using var connection = new SqlConnection(connString);
    await connection.OpenAsync();
    // Database operations
} // Dispose called automatically, even if exception occurs
catch (SqlException ex)
{
    _logger.LogError(ex, "Database operation failed");
    throw; // Re-throw with preserved stack trace
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="using-advantage">
                        <p><strong>Advantage:</strong> The <code>using</code> statement automatically expands to a try-finally block, ensuring proper disposal even if exceptions occur.</p>
                    </div>
                </div>

                <div class="exception-scenarios">
                    <h4>🎯 Exception Handling Scenarios</h4>
                    
                    <div class="scenario-grid">
                        <div class="scenario">
                            <h5>✅ With Catch Block</h5>
                            <p><strong>Result:</strong> Exception is handled, application continues</p>
                            <div class="code-example">
                                <pre><code>try
{
    // Risky operation
    int result = 10 / 0;
}
catch (DivideByZeroException ex)
{
    _logger.LogError(ex, "Division by zero occurred");
    // Application continues here
}</code></pre>
                            </div>
                        </div>

                        <div class="scenario">
                            <h5>❌ Without Catch Block</h5>
                            <p><strong>Result:</strong> Exception bubbles up, may crash application</p>
                            <div class="code-example">
                                <pre><code>try
{
    // Risky operation
    int result = 10 / 0; // DivideByZeroException
}
finally
{
    Console.WriteLine("Cleanup runs");
}
// Exception continues to bubble up
// Application may crash if not caught elsewhere</code></pre>
                            </div>
                        </div>

                        <div class="scenario">
                            <h5>🔄 With Multiple Catch Blocks</h5>
                            <p><strong>Result:</strong> Specific exception handling based on type</p>
                            <div class="code-example">
                                <pre><code>try
{
    await ProcessOrderAsync(orderId);
}
catch (ValidationException ex)
{
    return BadRequest(ex.Message);
}
catch (NotFoundException ex)
{
    return NotFound(ex.Message);
}
catch (Exception ex)
{
    _logger.LogError(ex, "Unexpected error processing order");
    return StatusCode(500, "Internal server error");
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="exception-flow-table">
                    <h4>📊 Exception Handling Outcomes</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Scenario</th>
                                <th>Has Catch?</th>
                                <th>Has Finally?</th>
                                <th>Program Continues?</th>
                                <th>Finally Runs?</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Exception thrown, catch exists</td>
                                <td>✅ Yes</td>
                                <td>Optional</td>
                                <td>Yes, after catch</td>
                                <td>Yes, if present</td>
                            </tr>
                            <tr>
                                <td>Exception thrown, no catch</td>
                                <td>❌ No</td>
                                <td>May exist</td>
                                <td>No, unless caught higher up</td>
                                <td>Yes, then bubbles up</td>
                            </tr>
                            <tr>
                                <td>Exception thrown, catch + finally</td>
                                <td>✅ Yes</td>
                                <td>✅ Yes</td>
                                <td>Yes, after finally</td>
                                <td>Always</td>
                            </tr>
                            <tr>
                                <td>No exception thrown</td>
                                <td>Skipped</td>
                                <td>May exist</td>
                                <td>Yes</td>
                                <td>Yes, if present</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="best-practices">
                    <h4>🎯 Enterprise Best Practices</h4>
                    
                    <div class="practice-grid">
                        <div class="practice-item good">
                            <h5>✅ Do This</h5>
                            <ul>
                                <li><strong>Catch specific exceptions first</strong> (SqlException, FileNotFoundException)</li>
                                <li><strong>Log all exceptions</strong> with context and correlation IDs</li>
                                <li><strong>Use structured logging</strong> (Serilog, Application Insights)</li>
                                <li><strong>Preserve stack traces</strong> with <code>throw;</code> not <code>throw ex;</code></li>
                                <li><strong>Use global exception middleware</strong> in ASP.NET Core</li>
                                <li><strong>Implement retry policies</strong> for transient failures</li>
                            </ul>
                        </div>

                        <div class="practice-item avoid">
                            <h5>❌ Avoid This</h5>
                            <ul>
                                <li><strong>Swallowing exceptions</strong> with empty catch blocks</li>
                                <li><strong>Catching Exception</strong> unless you re-throw</li>
                                <li><strong>Business logic in finally</strong> blocks</li>
                                <li><strong>Using exceptions for control flow</strong></li>
                                <li><strong>Generic error messages</strong> without context</li>
                                <li><strong>Ignoring inner exceptions</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="global-exception-handling">
                    <h4>🌐 Global Exception Handling in ASP.NET Core</h4>
                    <div class="code-example">
                        <pre><code>// Custom Exception Middleware
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;GlobalExceptionMiddleware&gt; _logger;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger&lt;GlobalExceptionMiddleware&gt; logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred. TraceId: {TraceId}", 
                context.TraceIdentifier);
            
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var response = exception switch
        {
            ValidationException => new { StatusCode = 400, Message = exception.Message },
            NotFoundException => new { StatusCode = 404, Message = "Resource not found" },
            UnauthorizedException => new { StatusCode = 401, Message = "Unauthorized" },
            _ => new { StatusCode = 500, Message = "An error occurred processing your request" }
        };

        context.Response.StatusCode = response.StatusCode;
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}

// Registration in Program.cs
app.UseMiddleware&lt;GlobalExceptionMiddleware&gt;();</code></pre>
                    </div>
                </div>

                <div class="interview-tips">
                    <h4>🎯 Interview-Ready Summary</h4>
                    <p>"In C#, I use try blocks around code that might fail—like database access or file I/O. The catch block lets me log and recover from errors, while finally ensures cleanup always happens. For disposable resources, I prefer using statements for cleaner code, but finally is crucial for manual resource management. In enterprise applications, I implement global exception middleware for consistent error handling and always log exceptions with proper context for debugging."</p>
                </div>
            </div>
            
            <div class="concept-card">
                <h3>Design Patterns</h3>
                <div class="patterns">
                    <div class="pattern">
                        <h4>Repository Pattern</h4>
                        <p>Decouples data access logic from business logic</p>
                        <div class="code-example">
                            <pre><code>public interface IUserRepository {
    Task&lt;User&gt; GetByIdAsync(int id);
    Task&lt;IEnumerable&lt;User&gt;&gt; GetAllAsync();
    Task AddAsync(User user);
}</code></pre>
                        </div>
                    </div>
                    <div class="pattern">
                        <h4>Unit of Work</h4>
                        <p>Maintains transaction consistency across multiple repositories</p>
                    </div>
                    <div class="pattern">
                        <h4>Factory Pattern</h4>
                        <p>Creates objects without specifying exact classes - useful in workflow engines</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Asynchronous Programming</h3>
                <div class="async-content">
                    <h4>async/await Pattern</h4>
                    <div class="code-example">
                        <pre><code>public async Task&lt;IActionResult&gt; GetUserAsync(int id) {
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Benefits:</strong> Better scalability, non-blocking operations, improved user experience</p>
                    <p><strong>Use Cases:</strong> File uploads, database operations, external API calls</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Security Best Practices</h3>
                <ul class="security-list">
                    <li><strong>Authentication:</strong> JWT tokens, OAuth2, Azure AD integration</li>
                    <li><strong>Authorization:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Data Protection:</strong> Encryption at rest and in transit</li>
                    <li><strong>Input Validation:</strong> Prevent SQL injection, XSS attacks</li>
                    <li><strong>HTTPS:</strong> Secure communication channels</li>
                </ul>
            </div>
        </section>

        <section id="best-practices" class="topic-section">
            <h2>Best Practices & DevOps</h2>
            
            <div class="concept-card">
                <h3>Code Quality</h3>
                <ul class="best-practices-list">
                    <li><strong>Clean Code:</strong> Descriptive naming, single responsibility</li>
                    <li><strong>Error Handling:</strong> Try-catch blocks, custom exceptions, logging</li>
                    <li><strong>Unit Testing:</strong> xUnit, NUnit, mocking with Moq</li>
                    <li><strong>Code Reviews:</strong> Peer review process, SOLID principles enforcement</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>DevOps & CI/CD</h3>
                <div class="devops-practices">
                    <div class="practice">
                        <h4>Azure DevOps Pipelines</h4>
                        <p>Automated build, test, and deployment processes</p>
                    </div>
                    <div class="practice">
                        <h4>Monitoring & Logging</h4>
                        <p>Application Insights, structured logging with Serilog</p>
                    </div>
                    <div class="practice">
                        <h4>Performance Optimization</h4>
                        <p>Profiling, query optimization, caching strategies</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Legacy System Maintenance</h3>
                <p>Working with 20+ year old platforms requires:</p>
                <ul>
                    <li>Careful integration between old and new components</li>
                    <li>Gradual migration strategies</li>
                    <li>Maintaining business continuity</li>
                    <li>Documentation of existing systems</li>
                    <li>Risk assessment for changes</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 .NET Interview Preparation Guide</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>
