<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Full Stack Interview Prep</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>.NET Full Stack Interview Preparation</h1>
            <p>Senior Software Engineer Interview Guide</p>
        </div>
    </header>

    <nav class="main-nav">
        <div class="container">
            <ul>
                <li><a href="#oop-concepts">OOP Concepts</a></li>
                <li><a href="#dotnet-fundamentals">.NET Fundamentals</a></li>
                <li><a href="#aspnet-webapi">ASP.NET Web API</a></li>
                <li><a href="#entity-framework">Entity Framework</a></li>
                <li><a href="#authentication-authorization">Auth & Security</a></li>
                <li><a href="#windows-services">Background Services</a></li>
                <li><a href="#database-sql">Database & SQL</a></li>
                <li><a href="#enterprise-architecture">Enterprise Architecture</a></li>
                <li><a href="#cloud-azure">Cloud & Azure</a></li>
                <li><a href="#advanced-concepts">Advanced Concepts</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="oop-concepts" class="topic-section">
            <h2>Core OOP Concepts</h2>
            
            <div class="concept-card">
                <h3>Classes and Objects</h3>
                <div class="concept-content">
                    <p><strong>Class:</strong> A blueprint for creating objects. Think of it as a template in enterprise systems.</p>
                    <p><strong>Object:</strong> An instance of a class with actual data.</p>
                    <div class="example">
                        <h4>Enterprise Example:</h4>
                        <p>In an HRMS system, <code>Employee</code> is a class defining properties like Name, EmployeeID, and methods like CalculateSalary(). Each actual employee record is an object of this class.</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>The Four Pillars of OOP</h3>
                
                <div class="pillar">
                    <h4>1. Encapsulation</h4>
                    <p>Bundling data and methods together while restricting access to internal components.</p>
                    <div class="code-example">
                        <pre><code>public class Account {
    private decimal balance;
    public void Deposit(decimal amount) { balance += amount; }
    public bool Withdraw(decimal amount) {
        if(amount > balance) return false;
        balance -= amount;
        return true;
    }
}</code></pre>
                    </div>
                    <p><strong>Why:</strong> Prevents unauthorized updates and ensures business rules are enforced.</p>
                </div>

                <div class="pillar">
                    <h4>2. Inheritance</h4>
                    <p>Creating new classes based on existing ones, inheriting properties and behaviors.</p>
                    <div class="code-example">
                        <pre><code>public class User {
    public string UserName { get; set; }
    public virtual void Login() { /* generic logic */ }
}
public class AdminUser : User {
    public override void Login() { /* admin-specific logic */ }
    public void ApproveUser() { /* only admin */ }
}</code></pre>
                    </div>
                    <p><strong>Enterprise Use:</strong> Multi-tenant SaaS with different user roles and privileges.</p>
                </div>

                <div class="pillar">
                    <h4>3. Polymorphism</h4>
                    <p>One interface, multiple implementations. Enables flexible, extensible code.</p>
                    <div class="polymorphism-types">
                        <h5>Compile-time (Method Overloading)</h5>
                        <div class="code-example">
                            <pre><code>public class DocumentGenerator {
    public void Generate(int templateId) { /* ... */ }
    public void Generate(string templateName) { /* ... */ }
    public void Generate(string title, string body) { /* ... */ }
}</code></pre>
                        </div>
                        
                        <h5>Runtime (Method Overriding)</h5>
                        <div class="code-example">
                            <pre><code>public interface IReportExporter {
    void Export(Report data);
}
public class PdfExporter : IReportExporter { ... }
public class ExcelExporter : IReportExporter { ... }</code></pre>
                        </div>
                    </div>
                </div>

                <div class="pillar">
                    <h4>4. Abstraction</h4>
                    <p>Hiding complex implementation details, showing only necessary features.</p>
                    <div class="code-example">
                        <pre><code>public interface IPaymentGateway {
    PaymentResult ProcessPayment(PaymentRequest request);
}
public class StripeGateway : IPaymentGateway { ... }
public class PaypalGateway : IPaymentGateway { ... }</code></pre>
                    </div>
                    <p><strong>Benefit:</strong> Swap payment providers with minimal code changes.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>SOLID Principles</h3>
                <p class="solid-intro">These five design principles are the backbone of maintainable, extensible, and testable enterprise .NET applications.</p>
                
                <div class="solid-principle-detailed">
                    <h4>1. Single Responsibility Principle (SRP)</h4>
                    <p class="principle-definition"><strong>"Every class should have one, and only one, reason to change."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Leave Management System</h5>
                        <ul>
                            <li><code>LeaveRequestService</code> - Handles business logic (validations, balance checks)</li>
                            <li><code>LeaveRequestRepository</code> - Database operations (CRUD for leave requests)</li>
                            <li><code>LeaveNotificationService</code> - Notifications (emails/SMS for approvals)</li>
                        </ul>
                        <p><strong>Why:</strong> If business rules change, only modify LeaveRequestService. If DB schema changes, only the repository is affected.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Classes doing everything—business logic, data access, email sending—become impossible to maintain and test.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>2. Open/Closed Principle (OCP)</h4>
                    <p class="principle-definition"><strong>"Software entities should be open for extension but closed for modification."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Invoice Generation Module</h5>
                        <div class="code-example">
                            <pre><code>public interface IInvoiceGenerator { 
    void Generate(InvoiceData data); 
}

public class GSTInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* GST logic */ }
}

public class ExportInvoiceGenerator : IInvoiceGenerator { 
    public void Generate(InvoiceData data) { /* Export logic */ }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Add new invoice types without touching existing code—prevents regressions.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Giant switch/case statements—every new type requires editing old code, risking bugs.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>3. Liskov Substitution Principle (LSP)</h4>
                    <p class="principle-definition"><strong>"Subclasses should be substitutable for their base class without breaking client code."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Banking System</h5>
                        <div class="code-example">
                            <pre><code>List&lt;Account&gt; accounts = new() { 
    new SavingsAccount(), 
    new CurrentAccount() 
};

foreach(var acc in accounts) 
    acc.Withdraw(amount); // Works for all account types</code></pre>
                        </div>
                        <p><strong>Why:</strong> Prevents surprises—subclasses maintain the parent's contract.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Derived classes that throw exceptions or do nothing—violates LSP.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>4. Interface Segregation Principle (ISP)</h4>
                    <p class="principle-definition"><strong>"Clients should not be forced to depend on interfaces they do not use."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: User Management Module</h5>
                        <div class="code-example">
                            <pre><code>// Instead of one giant IUserService with 30+ methods:
public interface IAuthenticationService { 
    void Login(); 
    void Logout(); 
}

public interface IProfileService { 
    void UpdateProfile(); 
    UserProfile GetProfile(); 
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Admin panel only needs IProfileService, login page only needs IAuthenticationService.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Fat interfaces where changes for one client break others.
                    </div>
                </div>

                <div class="solid-principle-detailed">
                    <h4>5. Dependency Inversion Principle (DIP)</h4>
                    <p class="principle-definition"><strong>"High-level modules should not depend on low-level modules, but on abstractions."</strong></p>
                    
                    <div class="enterprise-example">
                        <h5>Enterprise Example: Order Processing System</h5>
                        <div class="code-example">
                            <pre><code>public class OrderService
{
    private readonly IPaymentGateway _gateway;
    
    public OrderService(IPaymentGateway gateway) 
    { 
        _gateway = gateway; 
    }
    
    public void ProcessOrder(Order order)
    {
        // Can use StripeGateway, PayPalGateway, etc.
        _gateway.ProcessPayment(order.Total);
    }
}</code></pre>
                        </div>
                        <p><strong>Why:</strong> Easy testing (mock the gateway), painless vendor switching, supports DI frameworks.</p>
                    </div>
                    
                    <div class="common-pitfall">
                        <strong>⚠️ Common Pitfall:</strong> Directly instantiating dependencies inside classes—makes code rigid and untestable.
                    </div>
                </div>

                <div class="interview-tips">
                    <h4>🎯 How to Demonstrate SOLID in Interviews</h4>
                    <ul>
                        <li><strong>Refactoring:</strong> "We split our monolithic UserService into focused services for auth, profile, and roles to reduce bugs (SRP, ISP)."</li>
                        <li><strong>Extension:</strong> "When GST laws changed, we just added a new invoice generator—existing code didn't change (OCP)."</li>
                        <li><strong>Testing:</strong> "Using interfaces for repositories made it easy to mock dependencies for unit testing (DIP)."</li>
                        <li><strong>Bug Prevention:</strong> "We enforced LSP to fix broken polymorphism in our account hierarchy."</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="dotnet-fundamentals" class="topic-section">
            <h2>.NET Framework & .NET Core Fundamentals</h2>
            
            <div class="concept-card">
                <h3>.NET Framework vs .NET Core/.NET 5+</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>.NET Framework</th>
                                <th>.NET Core/.NET 5+</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Platform</td>
                                <td>Windows only</td>
                                <td>Cross-platform (Windows, Linux, macOS)</td>
                            </tr>
                            <tr>
                                <td>Deployment</td>
                                <td>Machine-wide installation</td>
                                <td>Side-by-side, self-contained</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>Good</td>
                                <td>Better, highly optimized</td>
                            </tr>
                            <tr>
                                <td>Use Cases</td>
                                <td>Legacy apps, WebForms, WCF, WinForms</td>
                                <td>Microservices, REST APIs, cloud-native</td>
                            </tr>
                            <tr>
                                <td>Deployment Target</td>
                                <td>On-premises servers</td>
                                <td>Containers, Azure, Docker</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="example">
                    <h4>Real Enterprise Migration:</h4>
                    <p>Many enterprises are migrating 15–20-year-old ASP.NET Framework web apps to .NET 6+ for containerization and Azure deployment, improving scalability and reducing infrastructure costs.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Solution & Project Structure</h3>
                <div class="enterprise-example">
                    <h5>Enterprise Solution Architecture</h5>
                    <div class="code-example">
                        <pre><code>MySolution/
├── Company.Product.WebApi/          # Web API controllers
├── Company.Product.Core/            # Business/domain logic
├── Company.Product.Data/            # EF Core/data access
├── Company.Product.Tests/           # Unit/integration tests
└── Company.Product.Infrastructure/  # External services</code></pre>
                    </div>
                    <ul>
                        <li><strong>Assembly:</strong> Output file (.dll/.exe) - unit of deployment and versioning</li>
                        <li><strong>Namespace:</strong> Logical grouping preventing naming conflicts</li>
                        <li><strong>Clean Separation:</strong> Supports maintainability, reusability, and CI/CD</li>
                    </ul>
                </div>
            </div>

            <div class="concept-card">
                <h3>CLR, CTS & Managed Code</h3>
                <div class="dotnet-architecture">
                    <div class="architecture-component">
                        <h4>CLR (Common Language Runtime)</h4>
                        <p>The virtual machine that runs .NET applications</p>
                        <ul>
                            <li>Memory management (Garbage Collection)</li>
                            <li>Type safety and security</li>
                            <li>Exception handling</li>
                            <li>Thread management</li>
                        </ul>
                    </div>
                    
                    <div class="architecture-component">
                        <h4>CTS (Common Type System)</h4>
                        <p>Defines how types are declared and used across languages</p>
                        <ul>
                            <li>Cross-language interoperability (C#, F#, VB.NET)</li>
                            <li>Type safety guarantees</li>
                            <li>Unified type system</li>
                        </ul>
                    </div>
                    
                    <div class="architecture-component">
                        <h4>Managed Code Benefits</h4>
                        <ul>
                            <li>Memory safety (no buffer overflows)</li>
                            <li>Automatic garbage collection</li>
                            <li>Security sandbox</li>
                            <li>Cross-platform deployment</li>
                        </ul>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Real Project Impact:</h4>
                    <p>Memory leaks, unhandled exceptions, and security vulnerabilities are minimized compared to unmanaged code (C/C++ DLLs), reducing production incidents and maintenance costs.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Key C# Language Features for Enterprise</h3>
                
                <div class="language-feature">
                    <h4>Async/Await</h4>
                    <p>Non-blocking operations crucial for scalable APIs</p>
                    <div class="code-example">
                        <pre><code>public async Task&lt;ActionResult&lt;User&gt;&gt; GetUserAsync(int id)
{
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Async DB queries, file uploads, external API calls</p>
                </div>

                <div class="language-feature">
                    <h4>LINQ (Language Integrated Query)</h4>
                    <p>Strongly-typed, chainable querying for in-memory and database operations</p>
                    <div class="code-example">
                        <pre><code>var activeUsers = await _context.Users
    .Where(u => u.IsActive && u.LastLoginDate > DateTime.Now.AddDays(-30))
    .OrderBy(u => u.LastName)
    .Select(u => new UserDto { Name = u.FullName, Email = u.Email })
    .ToListAsync();</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Generics & Type Safety</h4>
                    <p>Reusable, type-safe classes and methods</p>
                    <div class="code-example">
                        <pre><code>public class Repository&lt;T&gt; where T : class
{
    private readonly DbContext _context;
    
    public async Task&lt;T&gt; GetByIdAsync(int id) => 
        await _context.Set&lt;T&gt;().FindAsync(id);
        
    public async Task AddAsync(T entity) => 
        await _context.Set&lt;T&gt;().AddAsync(entity);
}</code></pre>
                    </div>
                </div>

                <div class="language-feature">
                    <h4>Delegates & Events</h4>
                    <p>Event-driven systems and pub-sub patterns</p>
                    <div class="code-example">
                        <pre><code>public event EventHandler&lt;OrderProcessedEventArgs&gt; OrderProcessed;

public async Task ProcessOrderAsync(Order order)
{
    // Process order logic
    await SaveOrderAsync(order);
    
    // Notify subscribers
    OrderProcessed?.Invoke(this, new OrderProcessedEventArgs(order));
}</code></pre>
                    </div>
                    <p><strong>Use Case:</strong> Real-time notifications, audit logging, workflow systems</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Dependency Injection & IoC</h3>
                <div class="di-explanation">
                    <h4>Why DI Matters in Enterprise</h4>
                    <ul>
                        <li>Promotes testability and loose coupling</li>
                        <li>Enables easy mocking for unit tests</li>
                        <li>Supports configuration-based service swapping</li>
                        <li>Facilitates clean architecture patterns</li>
                    </ul>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs / Startup.cs
builder.Services.AddScoped&lt;IUserService, UserService&gt;();
builder.Services.AddScoped&lt;IEmailService, EmailService&gt;();
builder.Services.AddSingleton&lt;IConfiguration&gt;(configuration);

// Controller
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly IEmailService _emailService;
    
    public UsersController(IUserService userService, IEmailService emailService)
    {
        _userService = userService;
        _emailService = emailService;
    }
}</code></pre>
                </div>

                <div class="di-lifetimes">
                    <h5>Service Lifetimes</h5>
                    <ul>
                        <li><strong>Transient:</strong> New instance every time (lightweight services)</li>
                        <li><strong>Scoped:</strong> One instance per request (repositories, business services)</li>
                        <li><strong>Singleton:</strong> Single instance for app lifetime (configuration, caching)</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Swap real email service for mock in integration tests without changing any business logic code.</p>
                </div>
            </div>
        </section>

        <section id="aspnet-webapi" class="topic-section">
            <h2>ASP.NET Core Web API</h2>
            
            <div class="concept-card">
                <h3>Controllers & Routing</h3>
                <p>RESTful endpoints for CRUD operations and business logic</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase 
{
    private readonly IOrderService _orderService;
    
    public OrdersController(IOrderService orderService)
    {
        _orderService = orderService;
    }
    
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; GetOrder(int id)
    {
        var order = await _orderService.GetByIdAsync(id);
        return order != null ? Ok(order) : NotFound();
    }
    
    [HttpPost]
    public async Task&lt;ActionResult&lt;OrderDto&gt;&gt; CreateOrder(CreateOrderRequest request)
    {
        var order = await _orderService.CreateAsync(request);
        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Model Binding & Validation</h3>
                <p>Enforces data integrity at API entry points</p>
                
                <div class="code-example">
                    <pre><code>public class CreateUserRequest
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }
    
    [Required]
    [StringLength(100, MinimumLength = 6)]
    public string Password { get; set; }
    
    [Range(18, 120)]
    public int Age { get; set; }
}

[HttpPost]
public async Task&lt;IActionResult&gt; CreateUser([FromBody] CreateUserRequest request)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
        
    // Process valid request
    var user = await _userService.CreateAsync(request);
    return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Middleware Pipeline</h3>
                <p>Components that process requests in sequence</p>
                
                <div class="middleware-pipeline">
                    <div class="middleware-component">
                        <h4>Authentication Middleware</h4>
                        <p>JWT token validation, OAuth2, Azure AD integration</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Authorization Middleware</h4>
                        <p>Role-based and policy-based access control</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Logging Middleware</h4>
                        <p>Request/response logging, correlation IDs</p>
                    </div>
                    <div class="middleware-component">
                        <h4>Exception Handling</h4>
                        <p>Global error handling and response formatting</p>
                    </div>
                </div>

                <div class="code-example">
                    <pre><code>// Program.cs
var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();
app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();
app.UseMiddleware&lt;GlobalExceptionMiddleware&gt;();

app.MapControllers();</code></pre>
                </div>
                
                <div class="example">
                    <h4>Banking App Example:</h4>
                    <p>JWT middleware authenticates every API request, logging middleware tracks all transactions with correlation IDs for audit trails.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>API Versioning</h3>
                <p>Supports multiple API versions for backward compatibility</p>
                
                <div class="code-example">
                    <pre><code>[ApiController]
[ApiVersion("1.0")]
[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public IActionResult GetUsersV1() => Ok(/* V1 response */);
    
    [HttpGet]
    [MapToApiVersion("2.0")]
    public IActionResult GetUsersV2() => Ok(/* V2 response with additional fields */);
}</code></pre>
                </div>
            </div>
        </section>

        <section id="entity-framework" class="topic-section">
            <h2>Entity Framework Core</h2>
            
            <div class="concept-card">
                <h3>ORM & Database Mapping</h3>
                <p>Maps database tables to C# classes with LINQ support</p>
                
                <div class="code-example">
                    <pre><code>public class User
{
    public int Id { get; set; }
    public string Email { get; set; }
    public DateTime CreatedOn { get; set; }
    public string CreatedBy { get; set; }
    
    // Navigation properties
    public virtual ICollection&lt;Order&gt; Orders { get; set; }
}

public class ApplicationDbContext : DbContext
{
    public DbSet&lt;User&gt; Users { get; set; }
    public DbSet&lt;Order&gt; Orders { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;User&gt;()
            .HasIndex(u => u.Email)
            .IsUnique();
            
        modelBuilder.Entity&lt;Order&gt;()
            .HasOne(o => o.User)
            .WithMany(u => u.Orders)
            .HasForeignKey(o => o.UserId);
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migrations & Schema Management</h3>
                <p>Version-controlled database schema changes</p>
                
                <div class="migration-commands">
                    <div class="command-group">
                        <h4>Common EF Core Commands</h4>
                        <div class="code-example">
                            <pre><code># Add new migration
dotnet ef migrations add AddUserTable

# Update database
dotnet ef database update

# Generate SQL script
dotnet ef migrations script</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Enterprise Benefit:</h4>
                    <p>Critical for team collaboration and CI/CD pipelines. Database changes are tracked, versioned, and can be automatically applied during deployments.</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>DbContext & Unit of Work</h3>
                <p>Manages queries, change tracking, and transactions</p>
                
                <div class="code-example">
                    <pre><code>public class OrderService
{
    private readonly ApplicationDbContext _context;
    
    public OrderService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task&lt;Order&gt; CreateOrderAsync(CreateOrderRequest request)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            var order = new Order { /* map properties */ };
            _context.Orders.Add(order);
            
            // Update inventory
            var product = await _context.Products.FindAsync(request.ProductId);
            product.Stock -= request.Quantity;
            
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
            
            return order;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Auto-generating audit columns (CreatedOn, ModifiedBy) via EF Core conventions and interceptors for compliance requirements.</p>
                </div>
            </div>
        </section>

        <section id="authentication-authorization" class="topic-section">
            <h2>Authentication & Authorization</h2>
            
            <div class="concept-card">
                <h3>Authentication - "Who are you?"</h3>
                
                <div class="auth-methods">
                    <div class="auth-method">
                        <h4>JWT Tokens</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = configuration["Jwt:Issuer"],
            ValidAudience = configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(configuration["Jwt:Key"]))
        };
    });</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-method">
                        <h4>OAuth2 & Azure AD</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApp(configuration.GetSection("AzureAd"));</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Authorization - "What can you do?"</h3>
                
                <div class="authorization-types">
                    <div class="auth-type">
                        <h4>Role-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>[Authorize(Roles = "Admin,Manager")]
public class AdminController : ControllerBase
{
    [HttpDelete("users/{id}")]
    [Authorize(Roles = "Admin")]
    public async Task&lt;IActionResult&gt; DeleteUser(int id) { /* */ }
}</code></pre>
                        </div>
                    </div>
                    
                    <div class="auth-type">
                        <h4>Policy-Based Authorization</h4>
                        <div class="code-example">
                            <pre><code>services.AddAuthorization(options =>
{
    options.AddPolicy("CanManageUsers", policy =>
        policy.RequireClaim("permission", "users.manage"));
        
    options.AddPolicy("MinimumAge", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

[Authorize(Policy = "CanManageUsers")]
public class UserManagementController : ControllerBase { /* */ }</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>HRMS system with role-based access: Employees can view their own data, Managers can approve leave requests, HR Admins can manage all employee records.</p>
                </div>
            </div>
        </section>

        <section id="windows-services" class="topic-section">
            <h2>Windows Services & Background Jobs</h2>
            
            <div class="concept-card">
                <h3>Background Services Use Cases</h3>
                <ul class="service-use-cases">
                    <li>Scheduled database cleanup and maintenance</li>
                    <li>Email sending and notification processing</li>
                    <li>Data import/export operations</li>
                    <li>ETL (Extract, Transform, Load) jobs</li>
                    <li>File processing and monitoring</li>
                    <li>Report generation and distribution</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>.NET Worker Service</h3>
                <p>Modern approach for background services in .NET</p>
                
                <div class="code-example">
                    <pre><code>public class InvoiceProcessingService : BackgroundService
{
    private readonly ILogger&lt;InvoiceProcessingService&gt; _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public InvoiceProcessingService(
        ILogger&lt;InvoiceProcessingService&gt; logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var invoiceService = scope.ServiceProvider
                    .GetRequiredService&lt;IInvoiceService&gt;();
                
                await invoiceService.ProcessPendingInvoicesAsync();
                
                _logger.LogInformation("Invoice processing completed at {Time}", 
                    DateTimeOffset.Now);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing invoices");
            }
            
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h3>Deployment as Windows Service</h3>
                
                <div class="code-example">
                    <pre><code># Install as Windows Service
sc create "InvoiceProcessor" binpath="C:\Services\InvoiceProcessor.exe"

# Start the service
sc start "InvoiceProcessor"

# Or use .NET CLI
dotnet publish -c Release
sc create "MyService" binpath="C:\MyApp\MyService.exe"</code></pre>
                </div>
                
                <div class="example">
                    <h4>Real Example:</h4>
                    <p>Background invoice processing service that runs nightly, processes pending invoices, generates PDFs, sends emails, and logs progress for monitoring and troubleshooting.</p>
                </div>
            </div>
        </section>

        <section id="database-sql" class="topic-section">
            <h2>Database & SQL Server</h2>
            
            <div class="concept-card">
                <h3>Enterprise Database Concepts</h3>
                
                <div class="db-concept">
                    <h4>Complex Queries & Joins</h4>
                    <p>Healthcare EMR system example: joining patient, appointment, and treatment tables for comprehensive reports.</p>
                </div>

                <div class="db-concept">
                    <h4>Transactions</h4>
                    <p>ACID properties ensure data consistency in financial operations.</p>
                    <div class="code-example">
                        <pre><code>using (var transaction = context.Database.BeginTransaction()) {
    try {
        // Debit from source account
        sourceAccount.Balance -= amount;
        // Credit to destination account
        destAccount.Balance += amount;
        
        context.SaveChanges();
        transaction.Commit();
    } catch {
        transaction.Rollback();
        throw;
    }
}</code></pre>
                    </div>
                </div>

                <div class="db-concept">
                    <h4>Entity Framework</h4>
                    <p>ORM for mapping database tables to C# classes, simplifying CRUD operations.</p>
                    <ul>
                        <li>Code-First: Define models, generate database</li>
                        <li>Database-First: Generate models from existing database</li>
                        <li>Migrations: Version control for database schema</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="enterprise-architecture" class="topic-section">
            <h2>Enterprise Application Architecture</h2>
            
            <div class="concept-card">
                <h3>Layered Architecture</h3>
                <div class="architecture-layers">
                    <div class="layer">
                        <h4>Presentation Layer</h4>
                        <p>Controllers, Views, API endpoints</p>
                    </div>
                    <div class="layer">
                        <h4>Business Logic Layer</h4>
                        <p>Services, business rules, validation</p>
                    </div>
                    <div class="layer">
                        <h4>Data Access Layer</h4>
                        <p>Repositories, Entity Framework, database operations</p>
                    </div>
                    <div class="layer">
                        <h4>Database Layer</h4>
                        <p>SQL Server, stored procedures, data storage</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Integration Patterns</h3>
                <ul class="integration-list">
                    <li><strong>APIs:</strong> REST/GraphQL for system communication</li>
                    <li><strong>Message Queues:</strong> Azure Service Bus for async processing</li>
                    <li><strong>ETL Jobs:</strong> Data transformation between systems</li>
                    <li><strong>Event-Driven:</strong> Microservices communication</li>
                </ul>
            </div>
        </section>

        <section id="cloud-azure" class="topic-section">
            <h2>Cloud (Azure) & Modernization</h2>
            
            <div class="concept-card">
                <h3>Azure Services for .NET</h3>
                <div class="azure-services">
                    <div class="service">
                        <h4>Azure App Service</h4>
                        <p>Host web applications and APIs with auto-scaling</p>
                    </div>
                    <div class="service">
                        <h4>Azure SQL Database</h4>
                        <p>Managed SQL Server in the cloud</p>
                    </div>
                    <div class="service">
                        <h4>Azure Functions</h4>
                        <p>Serverless computing for scheduled tasks</p>
                    </div>
                    <div class="service">
                        <h4>Azure Service Bus</h4>
                        <p>Message queuing for decoupled systems</p>
                    </div>
                    <div class="service">
                        <h4>Azure Active Directory</h4>
                        <p>Identity and access management</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Migration Strategies</h3>
                <ul>
                    <li><strong>Lift and Shift:</strong> Move existing apps to cloud VMs</li>
                    <li><strong>Re-platform:</strong> Move to Azure App Service with minimal changes</li>
                    <li><strong>Refactor:</strong> Redesign for cloud-native features</li>
                    <li><strong>Hybrid:</strong> Keep some components on-premises, others in cloud</li>
                </ul>
            </div>
        </section>

        <section id="advanced-concepts" class="topic-section">
            <h2>Advanced Concepts</h2>
            
            <div class="concept-card">
                <h3>Design Patterns</h3>
                <div class="patterns">
                    <div class="pattern">
                        <h4>Repository Pattern</h4>
                        <p>Decouples data access logic from business logic</p>
                        <div class="code-example">
                            <pre><code>public interface IUserRepository {
    Task&lt;User&gt; GetByIdAsync(int id);
    Task&lt;IEnumerable&lt;User&gt;&gt; GetAllAsync();
    Task AddAsync(User user);
}</code></pre>
                        </div>
                    </div>
                    <div class="pattern">
                        <h4>Unit of Work</h4>
                        <p>Maintains transaction consistency across multiple repositories</p>
                    </div>
                    <div class="pattern">
                        <h4>Factory Pattern</h4>
                        <p>Creates objects without specifying exact classes - useful in workflow engines</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Asynchronous Programming</h3>
                <div class="async-content">
                    <h4>async/await Pattern</h4>
                    <div class="code-example">
                        <pre><code>public async Task&lt;IActionResult&gt; GetUserAsync(int id) {
    var user = await _userService.GetByIdAsync(id);
    if (user == null) return NotFound();
    return Ok(user);
}</code></pre>
                    </div>
                    <p><strong>Benefits:</strong> Better scalability, non-blocking operations, improved user experience</p>
                    <p><strong>Use Cases:</strong> File uploads, database operations, external API calls</p>
                </div>
            </div>

            <div class="concept-card">
                <h3>Security Best Practices</h3>
                <ul class="security-list">
                    <li><strong>Authentication:</strong> JWT tokens, OAuth2, Azure AD integration</li>
                    <li><strong>Authorization:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Data Protection:</strong> Encryption at rest and in transit</li>
                    <li><strong>Input Validation:</strong> Prevent SQL injection, XSS attacks</li>
                    <li><strong>HTTPS:</strong> Secure communication channels</li>
                </ul>
            </div>
        </section>

        <section id="best-practices" class="topic-section">
            <h2>Best Practices & DevOps</h2>
            
            <div class="concept-card">
                <h3>Code Quality</h3>
                <ul class="best-practices-list">
                    <li><strong>Clean Code:</strong> Descriptive naming, single responsibility</li>
                    <li><strong>Error Handling:</strong> Try-catch blocks, custom exceptions, logging</li>
                    <li><strong>Unit Testing:</strong> xUnit, NUnit, mocking with Moq</li>
                    <li><strong>Code Reviews:</strong> Peer review process, SOLID principles enforcement</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>DevOps & CI/CD</h3>
                <div class="devops-practices">
                    <div class="practice">
                        <h4>Azure DevOps Pipelines</h4>
                        <p>Automated build, test, and deployment processes</p>
                    </div>
                    <div class="practice">
                        <h4>Monitoring & Logging</h4>
                        <p>Application Insights, structured logging with Serilog</p>
                    </div>
                    <div class="practice">
                        <h4>Performance Optimization</h4>
                        <p>Profiling, query optimization, caching strategies</p>
                    </div>
                </div>
            </div>

            <div class="concept-card">
                <h3>Legacy System Maintenance</h3>
                <p>Working with 20+ year old platforms requires:</p>
                <ul>
                    <li>Careful integration between old and new components</li>
                    <li>Gradual migration strategies</li>
                    <li>Maintaining business continuity</li>
                    <li>Documentation of existing systems</li>
                    <li>Risk assessment for changes</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 .NET Interview Preparation Guide</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>
